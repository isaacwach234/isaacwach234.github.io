const GITHUB_USER = 'isaacwach234';
const GITHUB_REPO = 'isaacwach234.github.io';

let TAG_DATABASE = [], gitHubPat = null, tagCategorizer, tagIdCounter = 0;
let TAG_POPULARITY = {}; // For the optional popularity data
let baseTags = [], copyHistory = [], selectedTagIds = new Set(), sortableInstances = [];
let autocomplete = { active: false, index: -1, currentWord: '', suggestions: [] };
let hiddenCategories = new Set(), knownCategories = new Set(), favoriteTags = new Map();
const reduceMotionQuery = window.matchMedia ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
const prefersReducedMotion = reduceMotionQuery ? reduceMotionQuery.matches : false;

const element = (id) => document.getElementById(id);
const body = document.body, tagInput = element('tagInput'), swapsInput = element('swapsInput'), implicationsInput = element('implicationsInput'), blacklistInput = element('blacklistInput'), triggerInput = element('triggerInput'), appendInput = element('appendInput');
const deduplicateToggle = element('deduplicateToggle'), underscoreToggle = element('underscoreToggle'), enableWeightingToggle = element('enableWeightingToggle');
const sortSelect = element('sortSelect'), maxTagsInput = element('maxTagsInput'), tagOutput = element('tagOutput');
const copyButton = element('copyButton'), copyMessage = element('copyMessage'), historyContainer = element('history-container'), autocompleteBox = element('autocomplete-box');
const suggestBtn = element('suggest-btn'), themeButtons = document.querySelectorAll('.theme-button'), suggestionCountInput = element('suggestionCountInput');
const categoryToggleContainer = element('categoryToggleContainer'), hiddenCategoriesBanner = element('hiddenCategoriesBanner');
const favoritesContainer = element('favorites-container'), clearFavoritesButton = element('clearFavoritesButton');
const promptPreview = element('promptPreview'), promptPreviewMeta = element('promptPreviewMeta'), promptPreviewCopy = element('promptPreviewCopy');
const ratingSafe = element('rating-safe'), ratingGeneral = element('rating-general'), ratingQuestionable = element('rating-questionable');
const categoryPickerModal = element('categoryPickerModal'), categoryPickerList = element('categoryPickerList');
const categoryPickerTitle = element('categoryPickerTitle'), categoryPickerSearch = element('categoryPickerSearch');
const categoryPickerBackdrop = element('categoryPickerBackdrop'), categoryPickerClose = element('categoryPickerClose');
const howToPanel = element('howToPanel');
const copyJsonButton = element('copyJsonButton');

const HIDDEN_STORAGE_KEY = 'danbooru-muted-categories';
const FAVORITES_STORAGE_KEY = 'danbooru-tag-favorites';

const PROMPT_FLOW_PHASES = [
    { key: 'quality', label: 'Rendering & Quality', description: 'Lead with fidelity, rendering engines, lighting and post-processing cues.', categories: ['Quality', 'Style & Meta', 'Lighting & Effects', 'Rendering', 'Color & Lighting', 'Post-processing'], keywords: ['quality', 'masterpiece', 'best', 'render', 'lighting', 'hdr', 'ultra', 'detailed', 'cinematic', 'studio'] },
    { key: 'composition', label: 'Framing & Composition', description: 'Establish the shot, camera angle, framing and focus hierarchy.', categories: ['Composition', 'Camera & Perspective', 'Focus & Depth'], keywords: ['angle', 'shot', 'view', 'perspective', 'framing', 'focus', 'zoom', 'bokeh'] },
    { key: 'subjects', label: 'Primary Subjects', description: 'Identify the core characters or creatures the prompt should feature.', categories: ['Characters', 'Subject & Creatures'], keywords: ['girl', 'boy', 'woman', 'man', 'character', 'solo', 'duo', 'group', 'monster', 'animal'] },
    { key: 'features', label: 'Distinctive Features', description: 'Call out defining traits, anatomy and facial details.', categories: ['Face', 'Eyes', 'Hair', 'Body Parts'], keywords: ['eyes', 'hair', 'face', 'expression', 'smile', 'pose', 'body', 'figure', 'physique'] },
    { key: 'wardrobe', label: 'Wardrobe & Props', description: 'Describe outfits, accessories and notable equipment.', categories: ['Attire', 'Accessories', 'Held Items & Objects'], keywords: ['outfit', 'uniform', 'dress', 'armor', 'suit', 'clothing', 'accessory', 'weapon', 'holding', 'prop'] },
    { key: 'action', label: 'Action & Interaction', description: 'Capture the motion, pose or interaction taking place.', categories: ['Actions & Poses', 'Interaction'], keywords: ['standing', 'sitting', 'running', 'jumping', 'dancing', 'gesturing', 'hugging', 'fighting', 'pose'] },
    { key: 'environment', label: 'Environment & Atmosphere', description: 'Set the scene, background, weather and ambient mood.', categories: ['Setting & Environment', 'Background Elements', 'Weather & Atmosphere'], keywords: ['background', 'landscape', 'indoors', 'outdoors', 'city', 'forest', 'room', 'sky', 'sunset', 'night', 'rain', 'storm'] },
    { key: 'extras', label: 'Finishing Touches', description: 'Add final stylistic or catch-all descriptors.', categories: ['Uncategorized', 'Meta'], keywords: ['signature', 'watermark', 'text', 'border', 'frame'] }
];
const FLOW_PHASE_PRIORITY_KEYWORDS = {
    quality: [['masterpiece', 8], ['best quality', 7], ['ultra detailed', 6], ['cinematic lighting', 5], ['dramatic lighting', 4], ['8k', 3], ['4k', 3], ['hdr', 2]],
    composition: [['dynamic angle', 4], ['wide shot', 3], ['close-up', 3], ['looking at viewer', 2], ['from below', 2], ['from above', 2]],
    subjects: [['solo', 5], ['duo', 4], ['group', 3], ['portrait', 3], ['full body', 2], ['character focus', 4]],
    features: [['expression', 4], ['smile', 3], ['eye contact', 3], ['detailed eyes', 4], ['hair', 2], ['body', 2]],
    wardrobe: [['uniform', 4], ['dress', 4], ['armor', 4], ['outfit', 3], ['accessories', 2], ['weapon', 3], ['holding', 2]],
    action: [['dynamic pose', 4], ['action', 3], ['jumping', 3], ['running', 3], ['dancing', 2], ['gesturing', 2], ['standing', 1], ['sitting', 1]],
    environment: [['dramatic sky', 4], ['sunset', 4], ['night', 3], ['rain', 3], ['forest', 3], ['city', 3], ['indoors', 2], ['outdoors', 2], ['background', 2]],
    extras: [['clean background', 2], ['no text', 2], ['signature', -3], ['watermark', -4]]
};
const ILLUSTRIOUS_PROMPT_PHASES = [
    { key: 'artistStyle', label: 'Artist & Style', description: 'Optionally begin with artist tags or stylistic influences (use weights to blend as needed).', categories: ['Artists', 'Style & Meta', 'Rendering'], keywords: ['style', 'artist', 'redrop', 'semi-realistic', 'illustration', 'inspired', '90s anime', 'artstyle', 'digital painting'] },
    { key: 'subject', label: 'Subjects & Traits', description: 'Describe character counts, core traits, hair, eyes and wardrobe details.', categories: ['Characters', 'Subject & Creatures', 'Face', 'Eyes', 'Hair', 'Body Parts', 'Attire', 'Accessories'], keywords: ['1girl', '1boy', 'character', 'girl', 'boy', 'woman', 'man', 'hair', 'eyes', 'uniform', 'dress', 'maid', 'armor'] },
    { key: 'pose', label: 'Pose, Action & Expression', description: 'Add motions, gestures and expressions that define what is happening.', categories: ['Actions & Poses', 'Interaction', 'Emotion & Expression', 'Camera & Perspective'], keywords: ['pose', 'standing', 'sitting', 'running', 'jumping', 'holding', 'gesture', 'smile', 'angry', 'expression', 'middle finger', 'peace sign'] },
    { key: 'scene', label: 'Scene & Background', description: 'Outline the setting, time of day and environmental context.', categories: ['Setting & Environment', 'Background Elements', 'Weather & Atmosphere'], keywords: ['background', 'indoors', 'outdoors', 'cafe', 'forest', 'city', 'sunset', 'daytime', 'night', 'sky', 'landscape'] },
    { key: 'effects', label: 'Effects & Aesthetic Detail', description: 'Finish descriptive details with lighting, particles or stylistic flourishes.', categories: ['Lighting & Effects', 'Post-processing', 'Color & Lighting', 'Meta'], keywords: ['dramatic lighting', 'bokeh', 'glow', 'particles', 'effect', 'aesthetic', 'watercolor', 'film grain'] },
    { key: 'quality', label: 'Quality Boosters', description: 'Close with global quality tags to reinforce rendering fidelity.', categories: ['Quality'], keywords: ['masterpiece', 'best quality', 'ultra detailed', 'highres', '8k', '4k', 'hdr'] }
];
const ILLUSTRIOUS_PHASE_PRIORITY_KEYWORDS = {
    artistStyle: [['style', 4], ['artist', 4], ['redrop', 3], ['semi-realistic', 3], ['illustration', 2], ['90s anime', 2], ['artstyle', 2], ['digital painting', 2]],
    subject: [['girl', 4], ['boy', 3], ['character', 4], ['hair', 3], ['eyes', 3], ['uniform', 2], ['dress', 2], ['maid', 2], ['armor', 2]],
    pose: [['pose', 4], ['standing', 3], ['sitting', 3], ['running', 3], ['holding', 2], ['gesture', 2], ['smile', 2], ['angry', 2], ['expression', 3]],
    scene: [['background', 4], ['cafe', 3], ['forest', 3], ['city', 3], ['indoors', 2], ['outdoors', 2], ['sunset', 3], ['daytime', 2], ['night', 2], ['sky', 2]],
    effects: [['lighting', 4], ['dramatic', 3], ['bokeh', 3], ['glow', 3], ['particles', 2], ['watercolor', 2], ['effect', 2], ['film grain', 2]],
    quality: [['masterpiece', 8], ['best quality', 7], ['ultra detailed', 6], ['highres', 5], ['8k', 4], ['4k', 3], ['hdr', 3]]
};

function createPromptFlowConfig(phases, priorityKeywords, fallbackKey) { const processedPhases = phases.map(phase => ({ ...phase, keywordMatchers: (phase.keywords || []).map(keyword => keyword.toLowerCase()) })); const categoryMap = new Map(); processedPhases.forEach(phase => { (phase.categories || []).forEach(categoryName => categoryMap.set(categoryName, phase.key)); }); return { phases: processedPhases, priorityKeywords, fallbackKey: fallbackKey || (processedPhases[processedPhases.length - 1] || {}).key, categoryMap }; }
const PROMPT_FLOW_CONFIG = createPromptFlowConfig(PROMPT_FLOW_PHASES, FLOW_PHASE_PRIORITY_KEYWORDS, 'extras');
const ILLUSTRIOUS_FLOW_CONFIG = createPromptFlowConfig(ILLUSTRIOUS_PROMPT_PHASES, ILLUSTRIOUS_PHASE_PRIORITY_KEYWORDS, 'quality');
const categoryPickerState = { tagId: null };
function debounce(fn, wait = 300) { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => fn.apply(context, args), wait); }; }

class EnhancedTagCategorizer {
    constructor(tagMap, allTags, categoryOrder) { this.primaryIndex = tagMap; this.categoryOrder = categoryOrder; this.categories = [...new Set([...Object.values(tagMap), ...categoryOrder, 'Uncategorized'])]; this.patternIndex = { ends: {}, starts: {} }; this.keywordIndex = {}; this.buildHeuristicIndexes(allTags); this.buildEnhancedHeuristics(); }
    buildHeuristicIndexes(allTags) { const keywordCategoryCounts = {}; const suffixCategoryCounts = {}; const prefixCategoryCounts = {}; const COPYRIGHT_KEYWORDS = new Set(['(genshin_impact)', '(azur_lane)', '(touhou)', '(hololive)', '(fate/grand_order)']); allTags.forEach(tag => { const category = this.primaryIndex[tag]; if (!category) return; const words = tag.split('_'); if (words.length > 1) { words.forEach(word => { if (word.length < 4 || COPYRIGHT_KEYWORDS.has(word)) return; if (!keywordCategoryCounts[word]) keywordCategoryCounts[word] = {}; keywordCategoryCounts[word][category] = (keywordCategoryCounts[word][category] || 0) + 1; }); const suffix = words[words.length - 1]; if (!suffixCategoryCounts[suffix]) suffixCategoryCounts[suffix] = {}; suffixCategoryCounts[suffix][category] = (suffixCategoryCounts[suffix][category] || 0) + 1; const prefix = words[0]; if (!prefixCategoryCounts[prefix]) prefixCategoryCounts[prefix] = {}; prefixCategoryCounts[prefix][category] = (prefixCategoryCounts[prefix][category] || 0) + 1; } }); for (const keyword in keywordCategoryCounts) { const counts = keywordCategoryCounts[keyword]; const total = Object.values(counts).reduce((s, c) => s + c, 0); const [mostLikelyCategory, categoryCount] = Object.entries(counts).reduce((a, b) => a[1] > b[1] ? a : b); if (total > 5 && (categoryCount / total) > 0.8) this.keywordIndex[keyword] = mostLikelyCategory; } for (const suffix in suffixCategoryCounts) { const counts = suffixCategoryCounts[suffix]; const total = Object.values(counts).reduce((s, c) => s + c, 0); const [mostLikelyCategory, categoryCount] = Object.entries(counts).reduce((a, b) => a[1] > b[1] ? a : b); if (total > 10 && (categoryCount / total) > 0.75) this.patternIndex.ends[`_${suffix}`] = mostLikelyCategory; } for (const prefix in prefixCategoryCounts) { const counts = prefixCategoryCounts[prefix]; const total = Object.values(counts).reduce((s, c) => s + c, 0); const [mostLikelyCategory, categoryCount] = Object.entries(counts).reduce((a, b) => a[1] > b[1] ? a : b); if (total > 10 && (categoryCount / total) > 0.75) this.patternIndex.starts[`${prefix}_`] = mostLikelyCategory; } }
    buildEnhancedHeuristics() { this.characterPatterns = [ /\([^)]+\)$/, /_\([^)]+\)$/, /^[a-z]+_[a-z]+_\([^)]+\)$/ ]; this.qualityKeywords = new Set(['quality', 'masterpiece', 'best', 'high', 'ultra', 'super', 'extremely', 'detailed', 'resolution', 'res', '4k', '8k', 'hd', 'uhd', 'absurdres']); this.compositionKeywords = new Set(['shot', 'view', 'angle', 'perspective', 'focus', 'body', 'portrait', 'landscape', 'close-up', 'wide', 'cowboy', 'full', 'upper', 'lower']); this.bodyPartKeywords = new Set(['breasts', 'ass', 'butt', 'thighs', 'legs', 'arms', 'hands', 'feet', 'face', 'eyes', 'hair', 'skin', 'body', 'torso', 'chest', 'belly', 'navel', 'shoulders', 'back', 'neck', 'head', 'nose', 'lips', 'mouth']); this.clothingKeywords = new Set(['dress', 'shirt', 'pants', 'skirt', 'shorts', 'jacket', 'coat', 'bikini', 'swimsuit', 'underwear', 'bra', 'panties', 'socks', 'stockings', 'thighhighs', 'pantyhose', 'boots', 'shoes', 'gloves']); this.actionKeywords = new Set(['sitting', 'standing', 'lying', 'walking', 'running', 'jumping', 'dancing', 'singing', 'eating', 'drinking', 'sleeping', 'smiling', 'looking', 'holding', 'grabbing', 'touching', 'reaching']); this.settingKeywords = new Set(['background', 'outdoor', 'indoor', 'room', 'bedroom', 'bathroom', 'kitchen', 'school', 'office', 'beach', 'forest', 'city', 'sky', 'night', 'day', 'sunset', 'sunrise', 'moon', 'star', 'cloud']); }
    updateIndex(tag, newCategory) { this.primaryIndex[tag.toLowerCase().replace(/ /g, '_')] = newCategory; }
    categorizeEnhanced(tagString) { const tag = tagString.toLowerCase().replace(/ /g, '_'); if (this.primaryIndex[tag]) { return { category: this.primaryIndex[tag], source: 'Primary', confidence: 1.0 }; } for (const pattern of this.characterPatterns) { if (pattern.test(tag)) return { category: 'Characters', source: 'Smart (Character)', confidence: 0.95 }; } const words = tag.split('_'), scores = {}; words.forEach(word => { if (this.qualityKeywords.has(word)) scores['Quality'] = (scores['Quality'] || 0) + 0.8; if (this.compositionKeywords.has(word)) scores['Composition'] = (scores['Composition'] || 0) + 0.7; if (this.bodyPartKeywords.has(word)) scores['Body Parts'] = (scores['Body Parts'] || 0) + 0.9; if (this.clothingKeywords.has(word)) scores['Attire'] = (scores['Attire'] || 0) + 0.8; if (this.actionKeywords.has(word)) scores['Actions & Poses'] = (scores['Actions & Poses'] || 0) + 0.7; if (this.settingKeywords.has(word)) scores['Setting & Environment'] = (scores['Setting & Environment'] || 0) + 0.8; }); const colorWords = ['red', 'blue', 'green', 'yellow', 'purple', 'pink', 'orange', 'black', 'white', 'grey', 'gray', 'brown']; if (words.some(word => colorWords.includes(word))) { if (words.some(word => ['hair', 'eyes'].includes(word))) { scores['Hair'] = (scores['Hair'] || 0) + 0.6; scores['Eyes'] = (scores['Eyes'] || 0) + 0.6; } else if (words.some(word => this.clothingKeywords.has(word))) { scores['Attire'] = (scores['Attire'] || 0) + 0.5; } } if (Object.keys(scores).length > 0) { const bestCategory = Object.entries(scores).reduce((a, b) => a[1] > b[1] ? a : b); return { category: bestCategory[0], source: 'Smart Heuristic', confidence: Math.min(bestCategory[1], 0.9) }; } return this.categorizeOriginal(tagString); }
    categorizeOriginal(tagString) { const tag = tagString.toLowerCase().replace(/ /g, '_'); if (this.primaryIndex[tag]) return { category: this.primaryIndex[tag], source: 'Primary' }; if (tag.includes('(') && tag.includes(')')) { const seriesMatch = tag.match(/\(([^)]+)\)/); if (seriesMatch && this.primaryIndex[seriesMatch[1]]) return { category: 'Characters', source: 'Heuristic (Series)' }; return { category: 'Characters', source: 'Heuristic (Pattern)' }; } for (const prefix in this.patternIndex.starts) if (tag.startsWith(prefix)) return { category: this.patternIndex.starts[prefix], source: 'Pattern (Prefix)' }; for (const suffix in this.patternIndex.ends) if (tag.endsWith(suffix)) return { category: this.patternIndex.ends[suffix], source: 'Pattern (Suffix)' }; const words = tag.split('_'), categoryScores = {}; words.forEach(word => { if (this.keywordIndex[word]) categoryScores[this.keywordIndex[word]] = (categoryScores[this.keywordIndex[word]] || 0) + 1; }); if (Object.keys(categoryScores).length > 0) return { category: Object.keys(categoryScores).reduce((a, b) => categoryScores[a] > categoryScores[b] ? a : b), source: 'Heuristic (Keywords)' }; return { category: 'Uncategorized', source: 'Fallback' }; }
    categorize(tagString) { return this.categorizeOriginal(tagString); }
    categorizeSmart(tagString) { return this.categorizeEnhanced(tagString); }
}

const getFavoriteKey = (tag) => tag.toLowerCase().replace(/\s+/g, '_');
function loadHiddenCategories() { try { const stored = JSON.parse(localStorage.getItem(HIDDEN_STORAGE_KEY) || '[]'); hiddenCategories = new Set(stored); } catch (error) { console.warn('Failed to load muted categories from storage', error); hiddenCategories = new Set(); } }
function saveHiddenCategories() { localStorage.setItem(HIDDEN_STORAGE_KEY, JSON.stringify(Array.from(hiddenCategories))); }
function ensureCategoryRegistered(category) { const resolved = category || 'Uncategorized'; if (!knownCategories.has(resolved)) { knownCategories.add(resolved); renderCategoryFilters(); } }
const normalizeTagText = (tag) => tag.toLowerCase().replace(/_/g, ' ').trim();
function determinePromptFlowPhase(tag, config = PROMPT_FLOW_CONFIG) { const categoryName = tag.category || 'Uncategorized'; if (config.categoryMap.has(categoryName)) { return config.categoryMap.get(categoryName); } const normalized = normalizeTagText(tag.original); for (const phase of config.phases) { if (phase.keywordMatchers.some(keyword => normalized.includes(keyword))) { return phase.key; } } return config.fallbackKey; }
function computePromptFlowScore(tag, phaseKey, config = PROMPT_FLOW_CONFIG) { const normalized = normalizeTagText(tag.weighted || tag.original); const priorities = config.priorityKeywords[phaseKey] || []; let score = 0; for (const [keyword, weight] of priorities) { if (normalized.includes(keyword)) score += weight; } if (tag.categorySource === 'Primary') score += 0.5; const weightMatch = tag.weighted && tag.weighted.match(/:(\d+(?:\.\d+)?)/); if (weightMatch) score += parseFloat(weightMatch[1]) / 10; return score; }
function sortTagsByPromptFlow(tags, config = PROMPT_FLOW_CONFIG) { const groups = config.phases.map(phase => ({ phase, tags: [] })); const groupMap = new Map(groups.map(group => [group.phase.key, group])); const fallbackGroup = groupMap.get(config.fallbackKey) || groups[groups.length - 1]; tags.forEach(tag => { const key = determinePromptFlowPhase(tag, config); const targetGroup = groupMap.get(key) || fallbackGroup; targetGroup.tags.push(tag); }); groups.forEach(group => { group.tags.sort((a, b) => { const scoreDiff = computePromptFlowScore(b, group.phase.key, config) - computePromptFlowScore(a, group.phase.key, config); if (scoreDiff !== 0) return scoreDiff; const timeDiff = (a.addedAt || 0) - (b.addedAt || 0); if (timeDiff !== 0) return timeDiff; return a.original.localeCompare(b.original); }); }); return groups; }
function getAllKnownCategories() { const categories = new Set([...tagCategorizer?.categoryOrder || [], ...knownCategories, 'Uncategorized']); return Array.from(categories).filter(Boolean).sort((a, b) => a.localeCompare(b)); }
function renderCategoryPickerOptions(query = '') { if (!categoryPickerList) return; const search = query.trim().toLowerCase(); const categories = getAllKnownCategories().filter(category => !search || category.toLowerCase().includes(search)); const tag = baseTags.find(item => item.id === categoryPickerState.tagId); categoryPickerList.innerHTML = ''; if (categories.length === 0) { const empty = document.createElement('div'); empty.className = 'category-picker-empty'; empty.textContent = 'No categories matched your search.'; categoryPickerList.appendChild(empty); return; } categories.forEach(category => { const btn = document.createElement('button'); btn.type = 'button'; btn.className = 'category-list-btn'; btn.textContent = category; if (tag && tag.category === category) btn.classList.add('active'); btn.addEventListener('click', () => assignCategoryToTag(category)); categoryPickerList.appendChild(btn); }); }
function openCategoryPicker(tagId) { const tag = baseTags.find(item => item.id === tagId); if (!tag || !categoryPickerModal) return; categoryPickerState.tagId = tagId; if (categoryPickerTitle) { categoryPickerTitle.textContent = tag.original.replace(/_/g, ' '); } if (categoryPickerSearch) { categoryPickerSearch.value = ''; } renderCategoryPickerOptions(''); categoryPickerModal.classList.add('active'); if (categoryPickerSearch) { setTimeout(() => categoryPickerSearch.focus(), 50); } }
function closeCategoryPicker() { if (!categoryPickerModal) return; categoryPickerModal.classList.remove('active'); categoryPickerState.tagId = null; }
function assignCategoryToTag(category) { if (!categoryPickerState.tagId) return; const tag = baseTags.find(item => item.id === categoryPickerState.tagId); if (!tag) return; tag.category = category; tag.categorySource = 'Manual'; ensureCategoryRegistered(category); if (tagCategorizer) { tagCategorizer.updateIndex(tag.original, category); } closeCategoryPicker(); if (sortSelect.value === 'manual') { displayTags(); } else { displayTags(); } }
function renderCategoryFilters() { if (!categoryToggleContainer) return; const categories = Array.from(knownCategories); if (!categories.includes('Uncategorized')) categories.push('Uncategorized'); categories.sort((a, b) => a.localeCompare(b)); categoryToggleContainer.innerHTML = ''; if (categories.length === 0) { const placeholder = document.createElement('p'); placeholder.className = 'text-xs text-gray-500'; placeholder.textContent = 'Categories will appear after your first processing run.'; categoryToggleContainer.appendChild(placeholder); return; } const resetButton = document.createElement('button'); resetButton.type = 'button'; resetButton.className = `category-toggle-btn${hiddenCategories.size === 0 ? ' opacity-60 cursor-not-allowed' : ''}`; resetButton.textContent = 'Show all'; resetButton.disabled = hiddenCategories.size === 0; resetButton.addEventListener('click', () => { hiddenCategories.clear(); saveHiddenCategories(); displayTags(); }); categoryToggleContainer.appendChild(resetButton); categories.forEach(category => { const count = baseTags.filter(tag => (tag.category || 'Uncategorized') === category).length; const btn = document.createElement('button'); btn.type = 'button'; btn.className = `category-toggle-btn${hiddenCategories.has(category) ? ' muted' : ''}`; btn.dataset.category = category; btn.innerHTML = `<span>${category}</span><span class="text-[0.65rem] text-gray-400">${count}</span>`; btn.addEventListener('click', () => toggleCategoryMute(category)); categoryToggleContainer.appendChild(btn); }); updateHiddenCategoriesBanner(); }
function toggleCategoryMute(category) { if (hiddenCategories.has(category)) hiddenCategories.delete(category); else hiddenCategories.add(category); saveHiddenCategories(); displayTags(); }
function updateHiddenCategoriesBanner() { if (!hiddenCategoriesBanner) return; if (hiddenCategories.size === 0) { hiddenCategoriesBanner.classList.add('hidden'); } else { hiddenCategoriesBanner.classList.remove('hidden'); hiddenCategoriesBanner.textContent = `Muted categories (${hiddenCategories.size}): ${Array.from(hiddenCategories).join(', ')}`; } }
function loadFavorites() { try { const stored = JSON.parse(localStorage.getItem(FAVORITES_STORAGE_KEY) || '[]'); favoriteTags = new Map(stored.map(tag => [getFavoriteKey(tag), tag])); } catch (error) { console.warn('Failed to load favorites from storage', error); favoriteTags = new Map(); } }
function saveFavorites() { localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(Array.from(favoriteTags.values()))); }
function clearFavorites() { favoriteTags.clear(); saveFavorites(); renderFavorites(); refreshFavoriteIndicators(); }
function renderFavorites() { if (!favoritesContainer) return; favoritesContainer.innerHTML = ''; if (favoriteTags.size === 0) { favoritesContainer.innerHTML = '<p class="text-sm text-gray-500 italic">No favorites saved yet. Click the star on a tag to pin it here.</p>'; if (clearFavoritesButton) clearFavoritesButton.disabled = true; return; } if (clearFavoritesButton) clearFavoritesButton.disabled = false; const list = Array.from(favoriteTags.values()).sort((a, b) => a.localeCompare(b)); list.forEach(tag => { const pill = document.createElement('div'); pill.className = 'favorite-pill'; pill.title = 'Click to insert this tag into the prompt'; const text = document.createElement('span'); text.className = 'truncate max-w-[160px]'; text.textContent = underscoreToggle.checked ? tag.replace(/\s/g, '_') : tag.replace(/_/g, ' '); text.addEventListener('click', () => insertFavoriteTag(tag)); pill.appendChild(text); const removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.innerHTML = '&times;'; removeBtn.addEventListener('click', () => { favoriteTags.delete(getFavoriteKey(tag)); saveFavorites(); renderFavorites(); refreshFavoriteIndicators(); }); pill.appendChild(removeBtn); favoritesContainer.appendChild(pill); }); }
function toggleFavorite(tagOriginal) { const key = getFavoriteKey(tagOriginal); if (favoriteTags.has(key)) { favoriteTags.delete(key); } else { favoriteTags.set(key, tagOriginal); } saveFavorites(); renderFavorites(); refreshFavoriteIndicators(); }
function refreshFavoriteIndicators() { document.querySelectorAll('.tag-favorite-btn').forEach(btn => { const original = btn.dataset.tagOriginal; const isFavorite = favoriteTags.has(getFavoriteKey(original)); btn.classList.toggle('active', isFavorite); btn.textContent = isFavorite ? '★' : '☆'; }); if (clearFavoritesButton) clearFavoritesButton.disabled = favoriteTags.size === 0; }
function insertFavoriteTag(tag) { const existing = tagInput.value.trim(); const normalizedTag = tag.replace(/_/g, ' '); const separator = existing && !existing.endsWith(',') ? ', ' : ''; const candidate = `${existing}${separator}${normalizedTag}`.trim(); tagInput.value = candidate; processAll(); }
function getProcessedTagElements() { return Array.from(tagOutput.querySelectorAll('.tag-base')); }
function getActiveTags() { return baseTags.filter(tag => !hiddenCategories.has(tag.category || 'Uncategorized')); }
function getProcessedTagsForOutput() { const elements = getProcessedTagElements(); return elements.map(el => { const weightedTag = el.dataset.weightedTag; return underscoreToggle.checked ? weightedTag.replace(/\s/g, '_') : weightedTag.replace(/_/g, ' '); }); }
function getPromptParts() { const prepend = triggerInput.value.split(',').map(t => t.trim()).filter(Boolean); const append = appendInput.value.split(',').map(t => t.trim()).filter(Boolean); const core = getProcessedTagsForOutput(); return { prepend, core, append }; }
function buildFinalPrompt() { const { prepend, core, append } = getPromptParts(); return [...prepend, ...core, ...append].join(', '); }
function estimateTokenCount(text) { if (!text || !text.trim()) return 0; const words = text.trim().split(/\s+/).filter(Boolean).length; return Math.max(words, Math.round(words * 1.3)); }
function updatePromptPreview() { if (!promptPreview) return; const finalString = buildFinalPrompt(); promptPreview.value = finalString; const characters = finalString.length; const words = finalString.trim() ? finalString.trim().split(/\s+/).filter(Boolean).length : 0; const tokens = estimateTokenCount(finalString); if (promptPreviewMeta) { const [charEl, wordEl, tokenEl] = promptPreviewMeta.querySelectorAll('span'); if (charEl) charEl.textContent = `Characters: ${characters}`; if (wordEl) wordEl.textContent = `Words: ${words}`; if (tokenEl) tokenEl.textContent = `Approx. tokens: ${tokens}`; } const isEmpty = finalString.length === 0; if (promptPreviewCopy) { promptPreviewCopy.disabled = isEmpty; } if (copyButton) { copyButton.disabled = isEmpty; } if (copyJsonButton) { copyJsonButton.disabled = isEmpty; } }
function processAll() { if (!tagCategorizer) return; const swaps = new Map(swapsInput.value.split(',').map(s => s.split('->').map(p => p.trim())).filter(p => p.length === 2 && p[0])); const implications = new Map(implicationsInput.value.split(',').map(s => s.split('=>').map(p => p.trim())).filter(p => p.length === 2 && p[0])); const blacklist = new Set(blacklistInput.value.replace(/[\n,]+/g, ',').split(',').map(w => w.trim().toLowerCase().replace(/_/g, ' ')).filter(Boolean)); let rawTags = tagInput.value.replace(/[\n]+/g, ',').split(',').map(t => t.trim()).filter(Boolean); rawTags = rawTags.map(tag => swaps.get(tag.toLowerCase().replace(/_/g, ' ')) || tag); const tagsToAdd = new Set(); rawTags.forEach(tag => { const lowerTag = tag.toLowerCase(); if (implications.has(lowerTag)) implications.get(lowerTag).split(',').forEach(imp => tagsToAdd.add(imp.trim())); }); rawTags = [...rawTags, ...tagsToAdd]; if (deduplicateToggle.checked) { const seen = new Set(); rawTags = rawTags.filter(tag => { const lower = tag.toLowerCase().replace(/_/g, ' '); if (seen.has(lower)) return false; seen.add(lower); return true; }); } let filteredTags = rawTags.filter(tag => !blacklist.has(tag.toLowerCase().replace(/_/g, ' '))); filteredTags = filteredTags.slice(0, parseInt(maxTagsInput.value, 10) || 75); const newBaseTags = []; const oldTagsMeta = new Map(baseTags.map(t => [t.original, { id: t.id, weighted: t.weighted, addedAt: t.addedAt }])); for (const tag of filteredTags) { const isSmartSort = sortSelect.value === 'smart'; const { category, source } = isSmartSort ? tagCategorizer.categorizeSmart(tag) : tagCategorizer.categorize(tag); const oldMeta = oldTagsMeta.get(tag); const assignedCategory = category || 'Uncategorized'; ensureCategoryRegistered(assignedCategory); newBaseTags.push({ original: tag, weighted: oldMeta ? oldMeta.weighted : tag, id: oldMeta ? oldMeta.id : `tag-${tagIdCounter++}`, category: assignedCategory, categorySource: source, addedAt: oldMeta && oldMeta.addedAt ? oldMeta.addedAt : Date.now() }); } if (!enableWeightingToggle.checked) newBaseTags.forEach(t => t.weighted = t.original); baseTags = newBaseTags; renderCategoryFilters(); displayTags(); }
function animateTagGroups() { if (!window.gsap || prefersReducedMotion) return; gsap.killTweensOf('.tag-group'); gsap.killTweensOf('.tag-group .tag-base'); gsap.from('.tag-group', { opacity: 0, y: 24, duration: 0.45, ease: 'power2.out', stagger: 0.08, overwrite: 'auto' }); gsap.from('.tag-group .tag-base', { opacity: 0, y: 12, duration: 0.3, ease: 'power1.out', stagger: 0.01, overwrite: 'auto' }); }

async function loadExt