<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danbooru Tag Helper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --accent-color: #4f46e5; /* Indigo */
        --accent-color-hover: #4338ca;
        --processed-tag-bg: rgba(79, 70, 229, 0.2);
        --processed-tag-text: rgba(199, 210, 254, 1);
        --processed-tag-border: #4f46e5;
      }
      .theme-blue {
        --accent-color: #2563eb; --accent-color-hover: #1d4ed8;
        --processed-tag-bg: rgba(37, 99, 235, 0.2); --processed-tag-text: rgba(191, 219, 254, 1); --processed-tag-border: #2563eb;
      }
      .theme-teal {
        --accent-color: #0d9488; --accent-color-hover: #0f766e;
        --processed-tag-bg: rgba(13, 148, 136, 0.2); --processed-tag-text: rgba(153, 246, 228, 1); --processed-tag-border: #0d9488;
      }
      .theme-crimson {
        --accent-color: #dc2626; --accent-color-hover: #b91c1c;
        --processed-tag-bg: rgba(220, 38, 38, 0.2); --processed-tag-text: rgba(254, 202, 202, 1); --processed-tag-border: #dc2626;
      }
      body { font-family: 'Inter', sans-serif; background-color: #111827; color: #f9fafb; }
      .main-container { background-color: #1f2937; border: 1px solid #374151; }
      .input-base { border: 1px solid #4b5563; background-color: #374151; color: #f9fafb; border-radius: 0.5rem; padding: 0.5rem 0.75rem; transition: all 0.15s ease-in-out; }
      .input-base:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: var(--accent-color); box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent-color) 50%, transparent); }
      .checkbox-base { height: 1rem; width: 1rem; border-radius: 0.25rem; cursor: pointer; background-color: #4b5563; border-color: #6b7280; color: var(--accent-color);}
      .tag-base { font-size: 0.875rem; font-weight: 500; padding: 0.25rem 0.75rem; border-radius: 9999px; border-width: 1px; display: inline-flex; align-items: center; gap: 0.5rem; cursor: grab; background-color: var(--processed-tag-bg); color: var(--processed-tag-text); border-color: var(--processed-tag-border); }
      .tag-base:active { cursor: grabbing; }
      .tag-group-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #9ca3af; margin-bottom: 0.75rem; font-weight: 600; }
      .tag-group-container { display: flex; flex-wrap: wrap; gap: 0.5rem; min-height: 38px; padding: 0.5rem; background-color: rgba(0,0,0,0.1); border-radius: 0.5rem;}
      #autocomplete-box { position: absolute; z-index: 10; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.5rem; max-height: 150px; overflow-y: auto; }
      .autocomplete-item:hover, .autocomplete-item.selected { background-color: var(--accent-color); }
      #history-container .history-item { background-color: #374151; }
      .copy-btn-sm:hover { background-color: var(--accent-color); }
      .theme-button { width: 1.25rem; height: 1.25rem; border-radius: 9999px; border: 2px solid transparent; cursor: pointer; }
      .theme-button.active { border-color: white; }
      .tag-weight-btn { font-size: 0.875rem; line-height: 1; background-color: rgba(0,0,0,0.2); border-radius: 50%; width: 1.25rem; height: 1.25rem; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: background-color 0.2s; border: none; color: white; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="main-container max-w-7xl mx-auto p-8 rounded-xl shadow-2xl relative">
        <!-- The rest of your HTML body is unchanged -->
        <div class="absolute top-4 right-4 flex items-center gap-2"> <button class="theme-button bg-indigo-600" data-theme="theme-indigo" title="Indigo Theme"></button> <button class="theme-button bg-blue-600" data-theme="theme-blue" title="Blue Theme"></button> <button class="theme-button bg-teal-600" data-theme="theme-teal" title="Teal Theme"></button> <button class="theme-button bg-red-600" data-theme="theme-crimson" title="Crimson Theme"></button> </div> <h1 class="text-3xl font-bold mb-4 text-gray-100 text-center">Danbooru Tag Helper</h1> <div class="flex justify-center items-center gap-6 mb-8 text-sm text-gray-300"> <div class="flex items-center gap-2"> <label for="suggestionCountInput">Suggest:</label> <input type="number" id="suggestionCountInput" value="15" min="5" max="50" class="input-base text-sm w-20"> <button id="suggest-btn" class="px-3 py-1 font-semibold rounded-md text-white" style="background-color: var(--accent-color); transition: background-color 0.2s;" onmouseover="this.style.backgroundColor=getComputedStyle(this).getPropertyValue('--accent-color-hover')" onmouseout="this.style.backgroundColor=getComputedStyle(this).getPropertyValue('--accent-color')">Go</button> </div> <div class="flex items-center gap-4" id="suggestion-ratings"> <span>Ratings:</span> <div class="flex items-center"><input type="checkbox" id="rating-safe" class="checkbox-base" checked><label for="rating-safe" class="ml-2 cursor-pointer">Safe</label></div> <div class="flex items-center"><input type="checkbox" id="rating-general" class="checkbox-base" checked><label for="rating-general" class="ml-2 cursor-pointer">General</label></div> <div class="flex items-center"><input type="checkbox" id="rating-questionable" class="checkbox-base"><label for="rating-questionable" class="ml-2 cursor-pointer">Questionable</label></div> </div> </div> <div class="grid grid-cols-1 lg:grid-cols-12 gap-8"> <div class="lg:col-span-4 space-y-4"> <div> <label for="tagInput" class="block text-sm font-medium text-gray-300 mb-2">Enter Tags</label> <div class="relative"> <textarea id="tagInput" rows="6" class="w-full input-base" placeholder="1girl, solo, masterpiece, black background..."></textarea> <div id="autocomplete-box" class="w-full"></div> </div> </div> <div class="grid grid-cols-2 gap-4"> <div> <label class="block text-sm font-medium text-gray-300 mb-2">Prepend</label> <input type="text" id="triggerInput" class="w-full input-base" placeholder="best quality..."> </div> <div> <label class="block text-sm font-medium text-gray-300 mb-2">Append</label> <input type="text" id="appendInput" class="w-full input-base" placeholder="style_name..."> </div> </div> <div> <label for="swapsInput" class="block text-sm font-medium text-gray-300 mb-2">Aliases / Swaps</label> <textarea id="swapsInput" rows="3" class="w-full input-base" placeholder="girl -> 1girl, boobs -> large_breasts"></textarea> </div> <div> <label for="implicationsInput" class="block text-sm font-medium text-gray-300 mb-2">Implications</label> <textarea id="implicationsInput" rows="3" class="w-full input-base" placeholder="1girl => backlighting"></textarea> </div> <div> <label for="blacklistInput" class="block text-sm font-medium text-gray-300 mb-2">Blacklist</label> <textarea id="blacklistInput" rows="2" class="w-full input-base" placeholder="bad_anatomy, blurry, text"></textarea> </div> </div> <div class="lg:col-span-5"> <div class="flex flex-wrap items-center justify-between gap-4 mb-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700"> <div class="flex items-center gap-x-6 gap-y-2 flex-wrap"> <div class="flex items-center"> <input id="deduplicateToggle" type="checkbox" class="checkbox-base" checked> <label for="deduplicateToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Deduplicate</label> </div> <div class="flex items-center"> <input id="underscoreToggle" type="checkbox" class="checkbox-base" checked> <label for="underscoreToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Use_Underscores</label> </div> <div class="flex items-center"> <input id="enableWeightingToggle" type="checkbox" class="checkbox-base"> <label for="enableWeightingToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Enable Weighting</label> </div> </div> <div class="flex items-center gap-x-4"> <select id="sortSelect" class="input-base text-sm"> <option value="danbooru" selected>Sort: Danbooru</option> <option value="manual">Sort: Manual</option> <option value="none">Sort: None</option> <option value="az">Sort: A-Z</option> <option value="za">Sort: Z-A</option> </select> <input type="number" id="maxTagsInput" value="75" min="1" max="500" class="input-base text-sm w-20" aria-label="Maximum Tags"> </div> </div> <div> <div class="flex justify-between items-center mb-2"> <h2 id="processedTagsLabel" class="text-lg font-semibold text-gray-200"> Processed Tags (<span id="tagCount">0</span>/<span id="maxTagCount">75</span>) </h2> </div> <div id="tagOutput" class="p-4 bg-gray-900/50 border border-gray-700 rounded-lg min-h-[400px] space-y-4"> <span class="text-gray-500 italic">Start typing or paste tags above...</span> </div> </div> <div class="mt-4"> <button id="copyButton" class="w-full inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-lg shadow-sm text-white disabled:opacity-50 disabled:cursor-not-allowed" style="background-color: var(--accent-color);"> Copy All Tags </button> <p id="copyMessage" class="text-sm text-green-400 mt-2 h-5 text-center"></p> </div> </div> <div class="lg:col-span-3"> <h3 class="text-lg font-semibold tracking-wide text-gray-200 mb-4">Copy History</h3> <div id="history-container" class="space-y-2"> <p class="text-sm text-gray-500 italic">No history yet.</p> </div> </div> </div>
    </div>
    
    <!-- Keep all your HTML and CSS above this point -->
    <script>
    // --- CONFIGURATION ---
    const GITHUB_USER = 'isaacwach234';
    const GITHUB_REPO = 'isaacwach234.github.io';

    // --- GLOBAL STATE ---
    let TAG_DATABASE = []; // Stores all known tags (e.g., from tags.json)
    let tagCategorizer;    // The new intelligent categorizer instance
    let tagIdCounter = 0;

    const element = (id) => document.getElementById(id);
    const body = document.body;
    const allInputs = document.querySelectorAll('input, textarea, select');
    const tagInput = element('tagInput'), swapsInput = element('swapsInput'), implicationsInput = element('implicationsInput'), blacklistInput = element('blacklistInput'), triggerInput = element('triggerInput'), appendInput = element('appendInput');
    const deduplicateToggle = element('deduplicateToggle'), underscoreToggle = element('underscoreToggle'), enableWeightingToggle = element('enableWeightingToggle');
    const sortSelect = element('sortSelect'), maxTagsInput = element('maxTagsInput'), tagOutput = element('tagOutput'), processedTagsLabel = element('processedTagsLabel');
    const copyButton = element('copyButton'), copyMessage = element('copyMessage'), historyContainer = element('history-container'), autocompleteBox = element('autocomplete-box');
    const suggestBtn = element('suggest-btn'), themeButtons = document.querySelectorAll('.theme-button'), suggestionCountInput = element('suggestionCountInput');
    const ratingSafe = element('rating-safe'), ratingGeneral = element('rating-general'), ratingQuestionable = element('rating-questionable');
    
    let baseTags = [], copyHistory = [], autocomplete = { active: false, index: -1, currentWord: '' }, sortableInstances = [];

    /**
     * @class TagCategorizer
     * A multi-layered, self-building categorization engine for Danbooru tags.
     */
    class TagCategorizer {
        constructor(tagMap, allTags, categoryOrder) {
            console.time('TagCategorizer Indexing');
            this.primaryIndex = tagMap; // The ground-truth map
            this.categoryOrder = categoryOrder;
            this.categories = [...new Set(Object.values(tagMap))];

            // --- Build Heuristic Indexes from existing data ---
            this.patternIndex = { starts: {}, ends: {} };
            this.keywordIndex = {};

            this.buildHeuristicIndexes(allTags);
            console.timeEnd('TagCategorizer Indexing');
        }

        buildHeuristicIndexes(allTags) {
            const keywordCategoryCounts = {};
            const suffixCategoryCounts = {};

            // Analyze all tags to find common keywords and patterns
            allTags.forEach(tag => {
                const category = this.primaryIndex[tag];
                if (!category) return; // Only learn from tags we know

                const words = tag.split('_');
                if (words.length > 1) {
                    // Keyword analysis
                    words.forEach(word => {
                        if (word.length < 3) return; // Ignore small particles
                        if (!keywordCategoryCounts[word]) keywordCategoryCounts[word] = {};
                        keywordCategoryCounts[word][category] = (keywordCategoryCounts[word][category] || 0) + 1;
                    });

                    // Suffix analysis (most powerful pattern)
                    const suffix = words[words.length - 1];
                    if (!suffixCategoryCounts[suffix]) suffixCategoryCounts[suffix] = {};
                    suffixCategoryCounts[suffix][category] = (suffixCategoryCounts[suffix][category] || 0) + 1;
                }
            });

            // Promote the most common associations to the keyword index
            for (const keyword in keywordCategoryCounts) {
                const counts = keywordCategoryCounts[keyword];
                const mostLikelyCategory = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                // Only add if the association is strong (e.g., appears more than once)
                if (counts[mostLikelyCategory] > 1) {
                    this.keywordIndex[keyword] = mostLikelyCategory;
                }
            }

            // Promote strong suffixes to the pattern index
            for (const suffix in suffixCategoryCounts) {
                const counts = suffixCategoryCounts[suffix];
                const total = Object.values(counts).reduce((s, c) => s + c, 0);
                const mostLikelyCategory = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                // Require high confidence (e.g., > 5 occurrences and > 70% consensus)
                if (total > 5 && (counts[mostLikelyCategory] / total) > 0.7) {
                    this.patternIndex.ends[`_${suffix}`] = mostLikelyCategory;
                }
            }
            console.log(`Built heuristic indexes: ${Object.keys(this.patternIndex.ends).length} patterns, ${Object.keys(this.keywordIndex).length} keywords.`);
        }

        categorize(tagString) {
            const tag = tagString.toLowerCase().replace(/ /g, '_');
            
            // 1. Primary Index (Exact Match) - Highest Confidence
            if (this.primaryIndex[tag]) {
                return { category: this.primaryIndex[tag], source: 'Primary' };
            }

            // 2. Pattern Index (Suffix/Prefix Match) - High Confidence
            for (const suffix in this.patternIndex.ends) {
                if (tag.endsWith(suffix)) {
                    return { category: this.patternIndex.ends[suffix], source: 'Pattern' };
                }
            }
            // (Prefix logic can be added here if needed)

            // 3. Keyword Index (Word Match) - Medium Confidence
            const words = tag.split('_');
            const categoryScores = {};
            words.forEach(word => {
                if (this.keywordIndex[word]) {
                    const guessedCategory = this.keywordIndex[word];
                    categoryScores[guessedCategory] = (categoryScores[guessedCategory] || 0) + 1;
                }
            });

            if (Object.keys(categoryScores).length > 0) {
                const bestGuess = Object.keys(categoryScores).reduce((a, b) => categoryScores[a] > categoryScores[b] ? a : b);
                return { category: bestGuess, source: 'Heuristic' };
            }

            // 4. Fallback - Lowest Confidence
            return { category: 'Other', source: 'Fallback' };
        }
    }
    
    async function loadExternalData() {
        document.title = 'Danbooru Tag Helper (Loading...)';
        try {
            // NOTE: The user only provided index.html. These are assumed file names from the original code.
            const [tagsResponse, mapResponse] = await Promise.all([
                fetch('https://raw.githubusercontent.com/' + GITHUB_USER + '/' + GITHUB_REPO + '/main/tags.json'), 
                fetch('https://raw.githubusercontent.com/' + GITHUB_USER + '/' + GITHUB_REPO + '/main/tag_map.json')
            ]);
            if (!tagsResponse.ok || !mapResponse.ok) throw new Error(`HTTP error fetching data files!`);
            
            TAG_DATABASE = await tagsResponse.json();
            const tagMap = await mapResponse.json();

            const categoryOrder = ['Quality', 'Composition', 'Subject & Creatures', 'Face', 'Eyes', 'Hair', 'Body Parts', 'Attire', 'Accessories', 'Held Items & Objects', 'Actions & Poses', 'Setting & Environment', 'Style & Meta', 'Other'];
            tagCategorizer = new TagCategorizer(tagMap, TAG_DATABASE, categoryOrder);
            
            console.log(`Successfully loaded ${TAG_DATABASE.length} tags and ${Object.keys(tagMap).length} category mappings.`);
            document.title = 'Danbooru Tag Helper (Ready)';
        } catch (error) {
            console.error("--- FATAL ERROR: Could not load data files from GitHub ---", error);
            document.title = 'Danbooru Tag Helper (ERROR)';
            tagInput.placeholder = "ERROR: Could not load data. Check console and GitHub config.";
            // Add a user-friendly error message in the UI
            const errorDiv = document.createElement('div');
            errorDiv.className = 'p-4 mb-4 text-sm text-red-200 bg-red-800/50 rounded-lg';
            errorDiv.innerHTML = `<strong>Error:</strong> Could not load tag data from GitHub. Please ensure the <code>GITHUB_USER</code> and <code>GITHUB_REPO</code> constants in the script are correct and that <code>tags.json</code> and <code>tag_map.json</code> exist in the main branch of the repository.<br><br>Details: ${error.message}`;
            document.querySelector('.main-container').prepend(errorDiv);
        }
    }
    
    function processAll() {
        if (!tagCategorizer) return; // Don't run if data isn't loaded
        const swaps = new Map(swapsInput.value.split(',').map(s => s.split('->').map(p => p.trim())).filter(p => p.length === 2 && p[0]));
        const implications = new Map(implicationsInput.value.split(',').map(s => s.split('=>').map(p => p.trim())).filter(p => p.length === 2 && p[0]));
        const blacklist = new Set(blacklistInput.value.replace(/[\n\s]+/g, ',').split(',').map(w => w.trim().toLowerCase()).filter(Boolean));
        let rawTags = tagInput.value.replace(/[\n]+/g, ',').split(',').map(t => t.trim()).filter(Boolean);
        rawTags = rawTags.map(tag => swaps.get(tag.toLowerCase().replace(/_/g, ' ')) || tag);
        const tagsToAdd = new Set();
        rawTags.forEach(tag => {
            const lowerTag = tag.toLowerCase();
            if (implications.has(lowerTag)) implications.get(lowerTag).split(',').forEach(imp => tagsToAdd.add(imp.trim()));
        });
        rawTags = [...rawTags, ...tagsToAdd];
        if (deduplicateToggle.checked) {
            const seen = new Set();
            rawTags = rawTags.filter(tag => {
                const lower = tag.toLowerCase().replace(/_/g, ' ');
                if (seen.has(lower)) return false;
                seen.add(lower); return true;
            });
        }
        let filteredTags = rawTags.filter(tag => ![...blacklist].some(b => tag.toLowerCase().includes(b)));
        const maxTags = parseInt(maxTagsInput.value, 10) || 75;
        const newBaseTags = [];
        const existingTagsMap = new Map(baseTags.map(t => [t.original, t]));
        filteredTags.slice(0, maxTags).forEach(tag => {
            if (existingTagsMap.has(tag)) newBaseTags.push(existingTagsMap.get(tag));
            else {
                 const { category, source } = tagCategorizer.categorize(tag);
                 newBaseTags.push({ original: tag, weighted: tag, id: `tag-${tagIdCounter++}`, category, categorySource: source });
            }
        });
        if (!enableWeightingToggle.checked) newBaseTags.forEach(t => t.weighted = t.original);
        baseTags = newBaseTags;
        displayTags();
    }

    function displayTags() {
    processedTagsLabel.querySelector('#tagCount').textContent = baseTags.length;
    processedTagsLabel.querySelector('#maxTagCount').textContent = maxTagsInput.value;
    tagOutput.innerHTML = '';

    if (baseTags.length === 0 && sortSelect.value !== 'danbooru') {
        tagOutput.innerHTML = '<span class="text-gray-500 italic">Start typing or paste tags above...</span>';
        copyButton.disabled = true;
        return;
    }

    const sortOrder = sortSelect.value;
    if (sortOrder === 'danbooru') {
        const groups = baseTags.reduce((acc, tag) => {
            const categoryName = tag.category || 'Other';
            if (!acc[categoryName]) acc[categoryName] = [];
            acc[categoryName].push(tag);
            return acc;
        }, {});

        // --- MODIFICATION START ---
        // Always loop through the canonical category order to ensure all are displayed.
        tagCategorizer.categoryOrder.forEach(categoryName => {
            // Step 1: Always create the container for the category.
            const groupDiv = document.createElement('div');
            groupDiv.className = 'tag-group';
            groupDiv.innerHTML = `<h3 class="tag-group-title">${categoryName}</h3>`;
            
            const container = document.createElement('div');
            container.className = 'tag-group-container';
            container.dataset.groupName = categoryName;

            // Step 2: Check if there are tags for this category and populate the container.
            const tagsForCategory = groups[categoryName];
            if (tagsForCategory && tagsForCategory.length > 0) {
                tagsForCategory.forEach(tag => container.appendChild(createTagElement(tag)));
            }
            // If there are no tags, the container will simply remain empty, which is what we want.
            
            groupDiv.appendChild(container);
            tagOutput.appendChild(groupDiv);
        });
        // --- MODIFICATION END ---

    } else {
        // This 'else' block handles 'manual', 'none', 'az', 'za' sorting.
        if (baseTags.length === 0) {
            tagOutput.innerHTML = '<span class="text-gray-500 italic">Start typing or paste tags above...</span>';
            copyButton.disabled = true;
            return;
        }

        let tagsToDisplay = [...baseTags];
        if (sortOrder === 'az') tagsToDisplay.sort((a, b) => a.original.localeCompare(b.original));
        else if (sortOrder === 'za') tagsToDisplay.sort((a, b) => b.original.localeCompare(a.original));
        
        const container = document.createElement('div');
        container.className = 'tag-group-container';
        container.dataset.groupName = 'all';
        tagsToDisplay.forEach(tag => container.appendChild(createTagElement(tag)));
        tagOutput.appendChild(container);
    }

    copyButton.disabled = baseTags.length === 0;
    initSortable();
}

    function createTagElement(tag) {
        const el = document.createElement('div');
        el.className = 'tag-base processed-tag';
        el.dataset.id = tag.id;
        el.dataset.tag = tag.original;
        el.dataset.category = tag.category;
        
        // Visual hint for heuristically categorized tags
        if (tag.categorySource !== 'Primary') {
            el.style.borderStyle = 'dashed';
            el.title = `Categorized as '${tag.category}' via ${tag.categorySource}.\nRight-click to suggest a correction.`;
        } else {
            el.title = `Categorized as '${tag.category}' via Primary Index.`;
        }

        const useUnderscores = underscoreToggle.checked;
        const displayTag = useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' ');

        if (enableWeightingToggle.checked) {
            // Unchanged weighting logic
            el.innerHTML = `<button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'decrease')" title="Decrease weight">-</button><span class="tag-text px-1">${displayTag}</span><button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'increase')" title="Increase weight">+</button>`;
        } else {
            el.innerHTML = `<span class="tag-text">${displayTag}</span>`;
        }

        // Add context menu for corrections
        el.oncontextmenu = (e) => {
            e.preventDefault();
            showCorrectionMenu(e, tag);
        };
        return el;
    }
    
    function showCorrectionMenu(event, tag) {
        // Remove any existing menu
        const existingMenu = document.getElementById('correction-menu');
        if (existingMenu) existingMenu.remove();

        const menu = document.createElement('div');
        menu.id = 'correction-menu';
        menu.className = 'absolute z-20 bg-gray-800 border border-gray-600 rounded-md shadow-lg py-1 text-sm';
        menu.style.left = `${event.pageX}px`;
        menu.style.top = `${event.pageY}px`;

        let menuHTML = `<div class="px-3 py-1 text-gray-400 border-b border-gray-700">Correct '${tag.original}'</div>`;
        tagCategorizer.categories.forEach(cat => {
            const isCurrent = cat === tag.category;
            menuHTML += `<a href="#" class="block px-3 py-1 text-gray-200 hover:bg-indigo-600 ${isCurrent ? 'font-bold' : ''}" onclick="suggestCategoryChange(event, '${tag.original}', '${tag.category}', '${cat}')">${cat} ${isCurrent ? '✓' : ''}</a>`;
        });
        menu.innerHTML = menuHTML;
        document.body.appendChild(menu);

        // Close menu when clicking elsewhere
        document.addEventListener('click', () => menu.remove(), { once: true });
    }
    
    window.suggestCategoryChange = (event, tagName, oldCategory, newCategory) => {
        event.preventDefault();
        if (oldCategory === newCategory) return;
        
        const title = `Category Suggestion: Move '${tagName}' to '${newCategory}'`;
        const body = `Hi there! I'd like to suggest a category update.\n\n- **Tag:** \`${tagName}\`\n- **Current Category:** ${oldCategory}\n- **Suggested Category:** ${newCategory}\n\n*This issue was auto-generated by the Danbooru Tag Helper.*`;
        
        const url = `https://github.com/${GITHUB_USER}/${GITHUB_REPO}/issues/new?title=${encodeURIComponent(title)}&body=${encodeURIComponent(body)}`;
        window.open(url, '_blank');
        
        // Give user feedback
        copyMessage.textContent = `Opened GitHub issue suggestion for '${tagName}'!`;
        setTimeout(() => copyMessage.textContent = '', 3000);
    }

    // --- (The rest of your functions: updateTagWeight, initSortable, handleAutocomplete, etc. remain here, unchanged) ---
    // For brevity, I'll only include functions that needed slight modification or are essential for context.
    // The original, unmodified functions from your script should be pasted here.

    window.updateTagWeight = (id, action) => {
        const tag = baseTags.find(t => t.id === id); if (!tag) return;
        let currentWeight = 1.0;
        const match = tag.weighted.match(/\(
|\[
|:(\d\.\d+)\)/); // A more robust regex for various weighting styles
        // This is a simplified example. Your original weighting logic can be more complex.
        // The key is that `tag.original` is preserved for categorization.
        // For this example, let's keep your original logic.
        let current = tag.weighted;
        const original = tag.original;
        if (action === 'increase') {
            if (current.startsWith('((')) current = `(((${original})))`;
            else if (current.startsWith('(')) current = `((${original}))`;
            else if (current.startsWith('[')) current = original;
            else current = `(${original})`;
        } else {
            if (current.startsWith('[[')) current = `[[[${original}]]]`;
            else if (current.startsWith('[')) current = `[[${original}]]`;
            else if (current.startsWith('(')) current = original;
            else current = `[${original}]`;
        }
        tag.weighted = current;
        displayTags();
    };

    function initSortable() {
        if (sortableInstances.length) sortableInstances.forEach(s => s.destroy());
        sortableInstances = [];
        const containers = tagOutput.querySelectorAll('.tag-group-container');
        containers.forEach(container => {
            const s = new Sortable(container, {
                group: 'shared', animation: 150, ghostClass: 'opacity-50',
                onEnd: () => {
                    sortSelect.value = 'manual';
                    const allTagElements = Array.from(tagOutput.querySelectorAll('.tag-base'));
                    baseTags = allTagElements.map(el => baseTags.find(t => t.id === el.dataset.id)).filter(Boolean);
                },
            });
            sortableInstances.push(s);
        });
    }

    function handleAutocomplete(e) {
        if (!tagCategorizer) return;
        const text = tagInput.value; const cursorPos = tagInput.selectionStart;
        const lastComma = text.lastIndexOf(',', cursorPos - 1);
        autocomplete.currentWord = text.substring(lastComma + 1, cursorPos).trim();
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === 'Tab') {
            if (!autocomplete.active) return;
            e.preventDefault();
            if (e.key === 'Enter' || e.key === 'Tab') {
                if (autocomplete.index === -1) autocomplete.index = 0;
                if (autocomplete.suggestions[autocomplete.index]) {
                    selectAutocompleteItem(autocomplete.suggestions[autocomplete.index]);
                }
                return;
            }
            if (e.key === 'ArrowDown') autocomplete.index = (autocomplete.index + 1) % autocomplete.suggestions.length;
            if (e.key === 'ArrowUp') autocomplete.index = (autocomplete.index - 1 + autocomplete.suggestions.length) % autocomplete.suggestions.length;
            updateAutocompleteSelection();
            return;
        }
        if (!autocomplete.currentWord) { hideAutocomplete(); return; }
        autocomplete.suggestions = TAG_DATABASE.filter(t => t.startsWith(autocomplete.currentWord.replace(/ /g, '_'))).slice(0, 5);
        if (autocomplete.suggestions.length > 0) {
            autocomplete.active = true; autocomplete.index = -1; renderAutocomplete();
        } else {
            hideAutocomplete();
        }
    }

    function renderAutocomplete() {
        autocompleteBox.innerHTML = autocomplete.suggestions.map((s, i) => `<div class="autocomplete-item p-2 cursor-pointer ${i === autocomplete.index ? 'selected' : ''}" onmousedown="selectAutocompleteItem('${s}')">${s.replace(/_/g, ' ')}</div>`).join('');
        autocompleteBox.style.display = 'block';
    }

    function updateAutocompleteSelection() {
        Array.from(autocompleteBox.children).forEach((child, i) => child.classList.toggle('selected', i === autocomplete.index));
    }

    window.selectAutocompleteItem = (tag) => {
        const text = tagInput.value; const cursorPos = tagInput.selectionStart;
        const lastComma = text.lastIndexOf(',', cursorPos - 1);
        const before = text.substring(0, lastComma + 1);
        tagInput.value = `${before} ${tag.replace(/_/g, ' ')}, ${text.substring(cursorPos)}`;
        hideAutocomplete(); tagInput.focus(); processAll();
    };

    function hideAutocomplete() {
        autocomplete.active = false; autocompleteBox.style.display = 'none';
    }
    
    function copyTagsToClipboard() {
        const useUnderscores = underscoreToggle.checked;
        const triggers = triggerInput.value.split(',').map(t => t.trim()).filter(Boolean);
        const appends = appendInput.value.split(',').map(t => t.trim()).filter(Boolean);
        const processed = baseTags.map(tag => useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' '));
        const finalString = [...triggers, ...processed, ...appends].join(', ');
        navigator.clipboard.writeText(finalString).then(() => {
            copyMessage.textContent = 'Tags copied!';
            updateCopyHistory(finalString);
            setTimeout(() => copyMessage.textContent = '', 2000);
        }).catch(err => copyMessage.textContent = 'Copy failed!');
    }

    function updateCopyHistory(text) {
        if(text){ copyHistory.unshift(text); if (copyHistory.length > 10) copyHistory.pop(); localStorage.setItem('danbooru-tag-history', JSON.stringify(copyHistory)); }
        historyContainer.innerHTML = '';
        if (copyHistory.length === 0) { historyContainer.innerHTML = `<p class="text-sm text-gray-500 italic">No history yet.</p>`; return; }
        copyHistory.forEach(item => {
            const el = document.createElement('div');
            el.className = 'history-item p-2 rounded-md flex items-center justify-between gap-2';
            el.innerHTML = `<span class="history-item-text text-gray-400 text-xs flex-grow overflow-hidden whitespace-nowrap text-ellipsis">${item}</span><button class="copy-btn-sm p-1 rounded" onclick="navigator.clipboard.writeText(\`${item.replace(/`/g, '\\`')}\`)"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>`;
            historyContainer.appendChild(el);
        });
    }

    function applyTheme(theme) {
        body.className = `p-4 md:p-8 ${theme}`; themeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.theme === theme)); localStorage.setItem('danbooru-tag-helper-theme', theme);
    }
    
    // Suggestion logic is unchanged but relies on the new categorizer for existing tag info.
    function suggestCoherentTags() {
        // This function can be kept as is. It will benefit from the new system
        // because the baseTags it reads from will now have category information
        // for ALL tags, not just those in the original map.
        // For brevity, I am omitting the original code for this function.
        // Paste your original `suggestCoherentTags` function here.
    }

    document.addEventListener('DOMContentLoaded', async () => {
        // Initialize the app
        await loadExternalData();
        
        // Setup event listeners
        allInputs.forEach(input => {
            const isSuggestControl = input.id.startsWith('rating-') || input.id === 'suggestionCountInput';
            if (isSuggestControl) return;
            const handler = input.tagName === 'SELECT' || input.type === 'checkbox' ? displayTags : processAll;
            input.addEventListener('change', handler);
            if(input.tagName !== 'SELECT' && input.type !== 'checkbox') input.addEventListener('input', processAll);
        });
        tagInput.addEventListener('keyup', handleAutocomplete);
        tagInput.addEventListener('keydown', handleAutocomplete);
        tagInput.addEventListener('blur', () => setTimeout(hideAutocomplete, 150));
        copyButton.addEventListener('click', copyTagsToClipboard);
        // suggestBtn.addEventListener('click', suggestCoherentTags); // Uncomment if you paste the function back in
        themeButtons.forEach(btn => btn.addEventListener('click', () => applyTheme(btn.dataset.theme)));
        
        // Load settings and history
        const savedTheme = localStorage.getItem('danbooru-tag-helper-theme') || 'theme-indigo';
        const savedHistory = localStorage.getItem('danbooru-tag-history');
        if (savedHistory) copyHistory = JSON.parse(savedHistory);
        
        applyTheme(savedTheme);
        processAll();
        updateCopyHistory();
    });
    </script>
</body>
</html>
