<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danbooru Tag Helper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --accent-color: #4f46e5; /* Indigo */
        --accent-color-hover: #4338ca;
        --processed-tag-bg: rgba(79, 70, 229, 0.2);
        --processed-tag-text: rgba(199, 210, 254, 1);
        --processed-tag-border: #4f46e5;
      }
      .theme-blue {
        --accent-color: #2563eb; --accent-color-hover: #1d4ed8;
        --processed-tag-bg: rgba(37, 99, 235, 0.2); --processed-tag-text: rgba(191, 219, 254, 1); --processed-tag-border: #2563eb;
      }
      .theme-teal {
        --accent-color: #0d9488; --accent-color-hover: #0f766e;
        --processed-tag-bg: rgba(13, 148, 136, 0.2); --processed-tag-text: rgba(153, 246, 228, 1); --processed-tag-border: #0d9488;
      }
      .theme-crimson {
        --accent-color: #dc2626; --accent-color-hover: #b91c1c;
        --processed-tag-bg: rgba(220, 38, 38, 0.2); --processed-tag-text: rgba(254, 202, 202, 1); --processed-tag-border: #dc2626;
      }
      body { font-family: 'Inter', sans-serif; background-color: #111827; color: #f9fafb; }
      .main-container { background-color: #1f2937; border: 1px solid #374151; }
      .input-base { border: 1px solid #4b5563; background-color: #374151; color: #f9fafb; border-radius: 0.5rem; padding: 0.5rem 0.75rem; transition: all 0.15s ease-in-out; }
      .input-base:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: var(--accent-color); box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent-color) 50%, transparent); }
      .checkbox-base { height: 1rem; width: 1rem; border-radius: 0.25rem; cursor: pointer; background-color: #4b5563; border-color: #6b7280; color: var(--accent-color);}
      .tag-base { font-size: 0.875rem; font-weight: 500; padding: 0.25rem 0.75rem; border-radius: 9999px; border-width: 1px; display: inline-flex; align-items: center; gap: 0.5rem; cursor: grab; background-color: var(--processed-tag-bg); color: var(--processed-tag-text); border-color: var(--processed-tag-border); }
      .tag-base:active { cursor: grabbing; }
      .tag-group-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #9ca3af; margin-bottom: 0.75rem; font-weight: 600; }
      .tag-group-container { display: flex; flex-wrap: wrap; gap: 0.5rem; min-height: 38px; padding: 0.5rem; background-color: rgba(0,0,0,0.1); border-radius: 0.5rem;}
      #autocomplete-box { position: absolute; z-index: 10; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.5rem; max-height: 150px; overflow-y: auto; }
      .autocomplete-item:hover, .autocomplete-item.selected { background-color: var(--accent-color); }
      #history-container .history-item { background-color: #374151; }
      .copy-btn-sm:hover { background-color: var(--accent-color); }
      .theme-button { width: 1.25rem; height: 1.25rem; border-radius: 9999px; border: 2px solid transparent; cursor: pointer; }
      .theme-button.active { border-color: white; }
      .tag-weight-btn { font-size: 0.875rem; line-height: 1; background-color: rgba(0,0,0,0.2); border-radius: 50%; width: 1.25rem; height: 1.25rem; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: background-color 0.2s; border: none; color: white; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="main-container max-w-7xl mx-auto p-8 rounded-xl shadow-2xl relative">
        <div class="absolute top-4 right-4 flex items-center gap-2">
            <button class="theme-button bg-indigo-600" data-theme="theme-indigo" title="Indigo Theme"></button>
            <button class="theme-button bg-blue-600" data-theme="theme-blue" title="Blue Theme"></button>
            <button class="theme-button bg-teal-600" data-theme="theme-teal" title="Teal Theme"></button>
            <button class="theme-button bg-red-600" data-theme="theme-crimson" title="Crimson Theme"></button>
        </div>
        <h1 class="text-3xl font-bold mb-4 text-gray-100 text-center">Danbooru Tag Helper</h1>
        
        <!-- --- NEW: Suggestion options --- -->
        <div class="flex justify-center items-center gap-6 mb-8 text-sm text-gray-300">
            <div class="flex items-center gap-2">
                <label for="suggestionCountInput">Suggest:</label>
                <input type="number" id="suggestionCountInput" value="15" min="5" max="50" class="input-base text-sm w-20">
                <button id="suggest-btn" class="px-3 py-1 font-semibold rounded-md text-white" style="background-color: var(--accent-color); transition: background-color 0.2s;" onmouseover="this.style.backgroundColor=getComputedStyle(this).getPropertyValue('--accent-color-hover')" onmouseout="this.style.backgroundColor=getComputedStyle(this).getPropertyValue('--accent-color')">Go</button>
            </div>
            <div class="flex items-center gap-4" id="suggestion-ratings">
                <span>Ratings:</span>
                <div class="flex items-center"><input type="checkbox" id="rating-safe" class="checkbox-base" checked><label for="rating-safe" class="ml-2 cursor-pointer">Safe</label></div>
                <div class="flex items-center"><input type="checkbox" id="rating-general" class="checkbox-base" checked><label for="rating-general" class="ml-2 cursor-pointer">General</label></div>
                <div class="flex items-center"><input type="checkbox" id="rating-questionable" class="checkbox-base"><label for="rating-questionable" class="ml-2 cursor-pointer">Questionable</label></div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Left Column: Inputs -->
            <div class="lg:col-span-4 space-y-4">
                 <div>
                    <label for="tagInput" class="block text-sm font-medium text-gray-300 mb-2">Enter Tags</label>
                    <div class="relative">
                        <textarea id="tagInput" rows="6" class="w-full input-base" placeholder="1girl, solo, masterpiece, black background..."></textarea>
                        <div id="autocomplete-box" class="w-full"></div>
                    </div>
                </div>
                 <div class="grid grid-cols-2 gap-4">
                    <div>
                         <label class="block text-sm font-medium text-gray-300 mb-2">Prepend</label>
                         <input type="text" id="triggerInput" class="w-full input-base" placeholder="best quality...">
                    </div>
                    <div>
                         <label class="block text-sm font-medium text-gray-300 mb-2">Append</label>
                         <input type="text" id="appendInput" class="w-full input-base" placeholder="style_name...">
                    </div>
                </div>
                 <div>
                    <label for="swapsInput" class="block text-sm font-medium text-gray-300 mb-2">Aliases / Swaps</label>
                    <textarea id="swapsInput" rows="3" class="w-full input-base" placeholder="girl -> 1girl, boobs -> large_breasts"></textarea>
                 </div>
                 <div>
                    <label for="implicationsInput" class="block text-sm font-medium text-gray-300 mb-2">Implications</label>
                    <textarea id="implicationsInput" rows="3" class="w-full input-base" placeholder="2girls => duo, uniform => clothing"></textarea>
                 </div>
                 <div>
                    <label for="blacklistInput" class="block text-sm font-medium text-gray-300 mb-2">Blacklist</label>
                    <textarea id="blacklistInput" rows="2" class="w-full input-base" placeholder="bad_anatomy, blurry, text"></textarea>
                 </div>
            </div>

            <!-- Center Column: Processed Tags -->
            <div class="lg:col-span-5">
                <div class="flex flex-wrap items-center justify-between gap-4 mb-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
                     <div class="flex items-center gap-x-6 gap-y-2 flex-wrap">
                        <div class="flex items-center">
                            <input id="deduplicateToggle" type="checkbox" class="checkbox-base" checked>
                            <label for="deduplicateToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Deduplicate</label>
                        </div>
                        <div class="flex items-center">
                            <input id="underscoreToggle" type="checkbox" class="checkbox-base" checked>
                            <label for="underscoreToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Use_Underscores</label>
                        </div>
                         <div class="flex items-center">
                            <input id="enableWeightingToggle" type="checkbox" class="checkbox-base">
                            <label for="enableWeightingToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Enable Weighting</label>
                        </div>
                     </div>
                     <div class="flex items-center gap-x-4">
                         <select id="sortSelect" class="input-base text-sm">
                             <option value="expert" selected>Sort: Expert</option>
                             <option value="smart">Sort: Smart</option>
                             <option value="manual">Sort: Manual</option>
                             <option value="none">Sort: None</option>
                             <option value="az">Sort: A-Z</option>
                             <option value="za">Sort: Z-A</option>
                         </select>
                         <input type="number" id="maxTagsInput" value="75" min="1" max="500" class="input-base text-sm w-20" aria-label="Maximum Tags">
                    </div>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                         <h2 id="processedTagsLabel" class="text-lg font-semibold text-gray-200">
                            Processed Tags (<span id="tagCount">0</span>/<span id="maxTagCount">75</span>)
                        </h2>
                    </div>
                    <div id="tagOutput" class="p-4 bg-gray-900/50 border border-gray-700 rounded-lg min-h-[400px] space-y-4">
                        <span class="text-gray-500 italic">Start typing or paste tags above...</span>
                    </div>
                </div>
                 <div class="mt-4">
                    <button id="copyButton" class="w-full inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-lg shadow-sm text-white disabled:opacity-50 disabled:cursor-not-allowed" style="background-color: var(--accent-color);">
                        Copy All Tags
                    </button>
                    <p id="copyMessage" class="text-sm text-green-400 mt-2 h-5 text-center"></p>
                </div>
            </div>
            
            <!-- Right Column: History -->
            <div class="lg:col-span-3">
                 <h3 class="text-lg font-semibold tracking-wide text-gray-200 mb-4">Copy History</h3>
                 <div id="history-container" class="space-y-2">
                     <p class="text-sm text-gray-500 italic">No history yet.</p>
                 </div>
            </div>
        </div>
    </div>

        <!-- ( body HTML remains the same) -->

    <script>
    let TAG_DATABASE = [];
    let tagIdCounter = 0; // --- NEW: More robust way to generate unique IDs.

    // --- Keyword lists for best-effort rating filters ---
    const QUESTIONABLE_KEYWORDS = ['bikini', 'swimsuit', 'cleavage', 'breasts', 'ass', 'thighs', 'pantyhose', 'leotard', 'garter_belt', 'panty_shot', 'sideboob', 'topless', 'bra', 'panties', 'lingerie', 'seductive', 'bondage', 'shibari', 'partially_nude'];
    const EXPLICIT_KEYWORDS = ['pussy', 'penis', 'sex', 'oral', 'ahegao', 'nude', 'naked', 'cum', 'masturbation', 'fellatio', 'cunnilingus', 'prolapse'];
    
    // --- Data definitions ---
    const SMART_SORT_CATEGORIES = [ { name: 'Quality', keywords: ['masterpiece', 'best_quality', 'highres', 'absurdres'] }, { name: 'Composition', keywords: ['solo', 'duo', 'trio', 'group', 'portrait', 'full_body', 'upper_body', 'cowboy_shot', 'close-up'], regex: /^\d+(boy|girl)s?$/ }, { name: 'Subject', keywords: ['hatsune_miku', 'gawr_gura', 'genshin_impact', 'hololive', 'touhou', 'raven (dc)'] }, { name: 'Actions & Poses', keywords: ['looking_at_viewer', 'sitting', 'standing', 'lying', 'pout', 'spread_legs', 'on_back', 'leaning_forward'] }, { name: 'Expressions & Face', keywords: ['smile', 'open_mouth', 'blush', 'sad', 'angry', 'crying', 'tongue_out', 'ahegao', 'closed_mouth', 'closed_eyes', 'blue_eyes', 'purple_eyes'] }, { name: 'Hair', regex: /.+_hair$/, keywords: ['ahoge', 'purple_hair'] }, { name: 'Clothing', keywords: ['uniform', 'dress', 'shirt', 'skirt', 'pants', 'bra', 'panties', 'bikini', 'swimsuit', 'naked', 'nude', 'leotard', 'pantyhose', 'cape', 'cloak', 'costume'] }, { name: 'Body', keywords: ['breasts', 'ass', 'thighs', 'pussy', 'penis', 'navel', 'feet', 'hands', 'small_breasts', 'medium_breasts', 'large_breasts', 'grey_skin', 'colored_skin'] }, { name: 'Accessories', keywords: ['hat', 'glasses', 'ribbon', 'jewelry', 'hairband', 'choker', 'cat_ears', 'tail', 'forehead_jewel', 'fingerless_gloves', 'elbow_gloves', 'gloves'] }, { name: 'Environment', keywords: ['simple_background', 'white_background', 'black_background', 'transparent_background', 'outdoors', 'indoors', 'night', 'day', 'cityscape', 'sky', 'room'] }, { name: 'Art Style & Meta', keywords: ['monochrome', 'sketch', 'lineart', 'greyscale', 'comic', 'photo-realistic', 'shadow_hands', 'umbrakinesis', 'cinematic_lighting'] } ];
    const EXPERT_SORT_CATEGORIES = [ { name: 'Quality', keywords: ['masterpiece', 'best_quality', 'highres', 'absurdres', '4k', '8k'] }, { name: 'Composition', keywords: ['solo', 'duo', 'trio', 'group', 'portrait', 'full_body', 'upper_body', 'cowboy_shot', 'close-up', 'from_side', 'from_behind', 'from_above', 'from_below'], regex: /^\d+(boy|girl)s?$/ }, { name: 'Subject', keywords: ['hatsune_miku', 'gawr_gura', 'genshin_impact', 'hololive', 'touhou', 'spider-man', 'batman', 'superman', 'raven (dc)'] }, { name: 'Actions & Poses', keywords: ['looking_at_viewer', 'sitting', 'standing', 'lying', 'pout', 'spread_legs', 'on_back', 'leaning_forward', 'dancing', 'running', 'jumping', 'fighting', 'stretching', 'animal_hug', 'holding'] }, { name: 'Expressions & Face', keywords: ['smile', 'open_mouth', 'blush', 'sad', 'angry', 'crying', 'tongue_out', 'ahegao', 'closed_mouth', 'closed_eyes', 'winking', 'smirk', 'surprised', 'facial_mark', 'parted_bangs', 'short_eyebrows', ':3', ';d'] }, { name: 'Hair', regex: /.+_hair$/, keywords: ['ahoge', 'ponytail', 'twintails', 'braid', 'bob_cut', 'pixie_cut', 'long_hair', 'short_hair', 'very_long_hair', 'blonde_hair', 'green_hair', 'multicolored_hair', 'streaked_hair', 'two-tone_hair'] }, { name: 'Eyes', regex: /.+_eyes$/, keywords: ['heterochromia', 'glowing_eyes', 'heart-shaped_pupils'] }, { name: 'Core Clothing', keywords: ['school_uniform', 'dress', 'suit', 'armor', 'leotard', 'bikini', 'swimsuit', 'pajamas', 'naked', 'nude', 'superhero_costume', 'sweater', 'skirt', 'shirt', 'jacket', 'hood', 'hooded_jacket', 'pink_jacket', 'long_sleeves'] }, { name: 'Body', keywords: ['breasts', 'ass', 'thighs', 'pussy', 'penis', 'navel', 'feet', 'hands', 'abs', 'muscular', 'freckles', 'scar', 'tattoo', 'small_breasts', 'medium_breasts', 'large_breasts', 'grey_skin', 'colored_skin', 'skin_fang', 'collarbone', 'chibi'] }, { name: 'Outerwear', keywords: ['jacket', 'coat', 'cape', 'cloak', 'hoodie'] }, { name: 'Underwear', keywords: ['bra', 'panties', 'pantyhose', 'thighhighs', 'socks', 'garter_belt', 'black_pantyhose'] }, { name: 'Accessories', keywords: ['hat', 'glasses', 'ribbon', 'jewelry', 'hairband', 'choker', 'cat_ears', 'tail', 'forehead_jewel', 'fingerless_gloves', 'elbow_gloves', 'gloves', 'mask', 'scarf', 'belt', 'neckerchief', 'white_neckerchief', 'horns', 'pointy_ears', 'red_choker', 'sleeves_past_wrists', 'brush_stickers'] }, { name: 'Held Items', keywords: ['sword', 'gun', 'book', 'phone', 'cup', 'food', 'wand', 'holding_flower'] }, { name: 'Environment', keywords: ['simple_background', 'white_background', 'black_background', 'transparent_background', 'outdoors', 'indoors', 'night', 'day', 'cityscape', 'sky', 'room', 'forest', 'beach', 'space', 'blue_background', 'floral_background', 'pink_background'] }, { name: 'Art Style & Meta', keywords: ['monochrome', 'sketch', 'lineart', 'greyscale', 'comic', 'photo-realistic', 'shadow_hands', 'umbrakinesis', 'cinematic_lighting', 'volumetric_lighting', 'dutch_angle', 'motion_blur'] }, ];
    
    // --- Element selectors ---
    const body = document.body;
    const allInputs = document.querySelectorAll('input, textarea, select');
    const tagInput = document.getElementById('tagInput');
    const swapsInput = document.getElementById('swapsInput');
    const implicationsInput = document.getElementById('implicationsInput');
    const blacklistInput = document.getElementById('blacklistInput');
    const triggerInput = document.getElementById('triggerInput');
    const appendInput = document.getElementById('appendInput');
    const deduplicateToggle = document.getElementById('deduplicateToggle');
    const underscoreToggle = document.getElementById('underscoreToggle');
    const enableWeightingToggle = document.getElementById('enableWeightingToggle');
    const sortSelect = document.getElementById('sortSelect');
    const maxTagsInput = document.getElementById('maxTagsInput');
    const tagOutput = document.getElementById('tagOutput');
    const processedTagsLabel = document.getElementById('processedTagsLabel');
    const copyButton = document.getElementById('copyButton');
    const copyMessage = document.getElementById('copyMessage');
    const historyContainer = document.getElementById('history-container');
    const autocompleteBox = document.getElementById('autocomplete-box');
    const suggestBtn = document.getElementById('suggest-btn');
    const themeButtons = document.querySelectorAll('.theme-button');
    const suggestionCountInput = document.getElementById('suggestionCountInput');
    const ratingSafe = document.getElementById('rating-safe');
    const ratingGeneral = document.getElementById('rating-general');
    const ratingQuestionable = document.getElementById('rating-questionable');
    
    let baseTags = [], copyHistory = [], autocomplete = { active: false, index: -1, currentWord: '' }, sortableInstances = [];
    
    function processAll() {
        const swaps = new Map(swapsInput.value.split(',').map(s => s.split('->').map(p => p.trim())).filter(p => p.length === 2 && p[0]));
        const implications = new Map(implicationsInput.value.split(',').map(s => s.split('=>').map(p => p.trim())).filter(p => p.length === 2 && p[0]));
        const blacklist = new Set(blacklistInput.value.replace(/[\n\s]+/g, ',').split(',').map(w => w.trim().toLowerCase()).filter(Boolean));
        
        let rawTags = tagInput.value.replace(/[\n]+/g, ',').split(',').map(t => t.trim()).filter(Boolean);
        
        rawTags = rawTags.map(tag => {
            const lowerTag = tag.toLowerCase().replace(/_/g, ' ');
            return swaps.get(lowerTag) || tag;
        });
        
        const tagsToAdd = new Set();
        rawTags.forEach(tag => {
            if (implications.has(tag.toLowerCase())) {
                implications.get(tag.toLowerCase()).split(',').forEach(imp => tagsToAdd.add(imp.trim()));
            }
        });
        rawTags = [...rawTags, ...tagsToAdd];
        
        if (deduplicateToggle.checked) {
            const seen = new Set();
            rawTags = rawTags.filter(tag => {
                const lower = tag.toLowerCase().replace(/_/g, ' ');
                if (seen.has(lower)) { return false; } 
                else { seen.add(lower); return true; }
            });
        }
        
        let filteredTags = rawTags.filter(tag => ![...blacklist].some(b => tag.toLowerCase().includes(b)));
        const maxTags = parseInt(maxTagsInput.value, 10) || 75;
        
        const newBaseTags = [];
        const existingTagsMap = new Map(baseTags.map(t => [t.original, t]));
        
        filteredTags.slice(0, maxTags).forEach(tag => {
            if (existingTagsMap.has(tag)) {
                newBaseTags.push(existingTagsMap.get(tag));
            } else {
                newBaseTags.push({ original: tag, weighted: tag, id: `tag-${tagIdCounter++}` });
            }
        });
        
        if (!enableWeightingToggle.checked) {
            newBaseTags.forEach(t => t.weighted = t.original);
        }
        
        baseTags = newBaseTags;
        displayTags();
    }

    function displayTags() {
        const maxTags = parseInt(maxTagsInput.value, 10) || 75;
        processedTagsLabel.querySelector('#tagCount').textContent = baseTags.length;
        processedTagsLabel.querySelector('#maxTagCount').textContent = maxTags;
        tagOutput.innerHTML = '';
        
        if (baseTags.length === 0) {
            tagOutput.innerHTML = '<span class="text-gray-500 italic">Start typing or paste tags above...</span>';
            copyButton.disabled = true; return;
        }
        
        const sortOrder = sortSelect.value;
        let tagsToDisplay = [...baseTags];
        const getSortCategories = () => sortOrder === 'expert' ? EXPERT_SORT_CATEGORIES : SMART_SORT_CATEGORIES;
        
        if (sortOrder === 'smart' || sortOrder === 'expert') {
            const categories = getSortCategories();
            const groups = tagsToDisplay.reduce((acc, tag) => {
                const categoryName = getTagCategoryName(tag, categories);
                if (!acc[categoryName]) acc[categoryName] = [];
                acc[categoryName].push(tag);
                return acc;
            }, {});

            const sortedCategoryNames = categories.map(c => c.name).filter(name => groups[name]);
            if (groups['Other']) sortedCategoryNames.push('Other');

            sortedCategoryNames.forEach(categoryName => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'tag-group';
                groupDiv.innerHTML = `<h3 class="tag-group-title">${categoryName}</h3>`;
                const container = document.createElement('div');
                container.className = 'tag-group-container';
                container.dataset.groupName = categoryName;
                groups[categoryName].forEach(tag => {
                    const tagElement = createTagElement(tag);
                    if (tagElement) container.appendChild(tagElement); // Defensive check
                });
                groupDiv.appendChild(container);
                tagOutput.appendChild(groupDiv);
            });
        } else {
            if (sortOrder === 'az') tagsToDisplay.sort((a, b) => a.original.localeCompare(b.original));
            else if (sortOrder === 'za') tagsToDisplay.sort((a, b) => b.original.localeCompare(a.original));
            const container = document.createElement('div');
            container.className = 'tag-group-container';
            container.dataset.groupName = 'all';
            tagsToDisplay.forEach(tag => {
                const tagElement = createTagElement(tag);
                if (tagElement) container.appendChild(tagElement); // Defensive check
            });
            tagOutput.appendChild(container);
        }
        copyButton.disabled = false;
        initSortable();
    }
    
    // --- RESTORED FUNCTION ---
    function createTagElement(tag) {
        if (!tag || typeof tag.id === 'undefined') {
            console.error("Invalid tag object passed to createTagElement:", tag);
            return null; // Return null to prevent crash
        }
        const el = document.createElement('div');
        el.className = 'tag-base processed-tag';
        el.dataset.id = tag.id;
        const useUnderscores = underscoreToggle.checked;
        const displayTag = useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' ');

        if (enableWeightingToggle.checked) {
            el.style.paddingLeft = '0.375rem';
            el.oncontextmenu = (e) => {
                e.preventDefault();
                const weightVal = tag.weighted.match(/:(\d\.\d+)\)$/)?.[1] || '1.1';
                const newWeight = prompt(`Enter weight for "${tag.original}" (e.g., 1.1):`, weightVal);
                if (newWeight && !isNaN(parseFloat(newWeight))) {
                    tag.weighted = `(${tag.original}:${newWeight})`;
                    displayTags();
                }
            };
            el.innerHTML = `<button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'decrease')" title="Decrease weight">-</button><span class="tag-text px-1">${displayTag}</span><button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'increase')" title="Increase weight">+</button>`;
        } else {
            el.innerHTML = `<span class="tag-text">${displayTag}</span>`;
        }
        return el;
    }

    // --- RESTORED FUNCTION ---
    window.updateTagWeight = (id, action) => {
        const tag = baseTags.find(t => t.id === id); if (!tag) return;
        let current = tag.weighted; const original = tag.original;
        if (action === 'increase') {
            if (current.startsWith('((')) { current = `(((${original})))`; }
            else if (current.startsWith('(')) { current = `((${original}))`; }
            else if (current.startsWith('[')) { current = original; }
            else { current = `(${original})`; }
        } else { // decrease
            if (current.startsWith('[[')) { current = `[[[${original}]]]`; }
            else if (current.startsWith('[')) { current = `[[${original}]]`; }
            else if (current.startsWith('(')) { current = original; }
            else { current = `[${original}]`; }
        }
        tag.weighted = current; displayTags();
    };

    function getTagCategoryName(tag, categories) {
        const tagOriginal = (tag.original || tag).toLowerCase();
        const tagWithSpaces = tagOriginal.replace(/_/g, ' ');
        for (const category of categories) {
            if (category.regex && category.regex.test(tagOriginal)) return category.name;
            if (category.keywords?.some(k => k.replace(/_/g, ' ') === tagWithSpaces)) return category.name;
        }
        return 'Other';
    }

    function initSortable() {
        if (sortableInstances.length) {
            sortableInstances.forEach(s => s.destroy());
            sortableInstances = [];
        }
        const containers = tagOutput.querySelectorAll('.tag-group-container');
        containers.forEach(container => {
            const s = new Sortable(container, {
                group: 'shared', animation: 150, ghostClass: 'opacity-50',
                onEnd: () => {
                    sortSelect.value = 'manual';
                    const allTagElements = Array.from(tagOutput.querySelectorAll('.tag-base'));
                    baseTags = allTagElements.map(el => baseTags.find(t => t.id === el.dataset.id)).filter(Boolean);
                },
            });
            sortableInstances.push(s);
        });
    }

    // --- RESTORED FUNCTION ---
    function handleAutocomplete(e) {
        const text = tagInput.value; const cursorPos = tagInput.selectionStart;
        const lastComma = text.lastIndexOf(',', cursorPos - 1);
        autocomplete.currentWord = text.substring(lastComma + 1, cursorPos).trim();
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter') {
            if (!autocomplete.active) return;
            e.preventDefault();
            if (e.key === 'Enter') { if(autocomplete.suggestions[autocomplete.index]) selectAutocompleteItem(autocomplete.suggestions[autocomplete.index]); return; }
            if (e.key === 'ArrowDown') autocomplete.index = (autocomplete.index + 1) % autocomplete.suggestions.length;
            if (e.key === 'ArrowUp') autocomplete.index = (autocomplete.index - 1 + autocomplete.suggestions.length) % autocomplete.suggestions.length;
            updateAutocompleteSelection(); return;
        }
        if (!autocomplete.currentWord) { hideAutocomplete(); return; }
        autocomplete.suggestions = TAG_DATABASE.filter(t => t.startsWith(autocomplete.currentWord.replace(/ /g, '_'))).slice(0, 5);
        if (autocomplete.suggestions.length > 0) { autocomplete.active = true; autocomplete.index = -1; renderAutocomplete(); }
        else { hideAutocomplete(); }
    }

    // --- RESTORED FUNCTION ---
    function renderAutocomplete() {
        autocompleteBox.innerHTML = autocomplete.suggestions.map((s, i) => `<div class="autocomplete-item p-2 cursor-pointer ${i === autocomplete.index ? 'selected' : ''}" onmousedown="selectAutocompleteItem('${s}')">${s.replace(/_/g, ' ')}</div>`).join('');
        autocompleteBox.style.display = 'block';
    }

    // --- RESTORED FUNCTION ---
    function updateAutocompleteSelection() { Array.from(autocompleteBox.children).forEach((child, i) => child.classList.toggle('selected', i === autocomplete.index)); }

    // --- RESTORED FUNCTION ---
    window.selectAutocompleteItem = (tag) => {
        const text = tagInput.value; const cursorPos = tagInput.selectionStart;
        const lastComma = text.lastIndexOf(',', cursorPos - 1);
        const before = text.substring(0, lastComma + 1);
        tagInput.value = `${before} ${tag.replace(/_/g, ' ')}, ${text.substring(cursorPos)}`;
        hideAutocomplete(); tagInput.focus(); processAll();
    };

    function hideAutocomplete() { autocomplete.active = false; autocompleteBox.style.display = 'none'; }
    function copyTagsToClipboard() {
        const useUnderscores = underscoreToggle.checked;
        const triggers = triggerInput.value.split(',').map(t => t.trim()).filter(Boolean);
        const appends = appendInput.value.split(',').map(t => t.trim()).filter(Boolean);
        const processed = baseTags.map(tag => useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' '));
        const finalString = [...triggers, ...processed, ...appends].join(', ');
        navigator.clipboard.writeText(finalString).then(() => {
            copyMessage.textContent = 'Tags copied!';
            updateCopyHistory(finalString);
            setTimeout(() => copyMessage.textContent = '', 2000);
        }).catch(err => copyMessage.textContent = 'Copy failed!');
    }
    function updateCopyHistory(text) {
        if(text){ copyHistory.unshift(text); if (copyHistory.length > 10) copyHistory.pop(); localStorage.setItem('danbooru-tag-history', JSON.stringify(copyHistory)); }
        historyContainer.innerHTML = '';
        if (copyHistory.length === 0) { historyContainer.innerHTML = `<p class="text-sm text-gray-500 italic">No history yet.</p>`; return; }
        copyHistory.forEach(item => {
            const el = document.createElement('div');
            el.className = 'history-item p-2 rounded-md flex items-center justify-between gap-2';
            el.innerHTML = `<span class="history-item-text text-gray-400 text-xs flex-grow overflow-hidden whitespace-nowrap text-ellipsis">${item}</span><button class="copy-btn-sm p-1 rounded" onclick="navigator.clipboard.writeText(\`${item.replace(/`/g, '\\`')}\`)"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>`;
            historyContainer.appendChild(el);
        });
    }
    function applyTheme(theme) { body.className = `p-4 md:p-8 ${theme}`; themeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.theme === theme)); localStorage.setItem('danbooru-tag-helper-theme', theme); }

    function suggestCoherentTags() {
        if (TAG_DATABASE.length < 2) return;
        const numToSuggest = parseInt(suggestionCountInput.value, 10);
        const existingTags = new Set(baseTags.map(t => t.original.toLowerCase().replace(/ /g, '_')));
        const categories = EXPERT_SORT_CATEGORIES;
        const isAllowed = (tag) => {
            if (EXPLICIT_KEYWORDS.some(kw => tag.includes(kw))) return false;
            if (!ratingQuestionable.checked && QUESTIONABLE_KEYWORDS.some(kw => tag.includes(kw))) return false;
            return true;
        };
        let suggestions = new Set();
        const categoryPools = {};
        categories.forEach(c => categoryPools[c.name] = []);
        for (const tag of TAG_DATABASE) {
            if (existingTags.has(tag) || !isAllowed(tag)) continue;
            const categoryName = getTagCategoryName({ original: tag }, categories);
            if (categoryPools[categoryName] && categoryPools[categoryName].length < 100) {
                categoryPools[categoryName].push(tag);
            }
        }

        const plan = (existingTags.size === 0) 
            ? [ { name: 'Quality', count: 2 }, { name: 'Composition', count: 2 }, { name: 'Subject', count: 1 }, { name: 'Hair', count: 2 }, { name: 'Core Clothing', count: 1 }, { name: 'Actions & Poses', count: 2 }, { name: 'Environment', count: 2 } ]
            : Object.keys(baseTags.reduce((acc, tag) => { acc[getTagCategoryName(tag, categories)] = true; return acc; }, {})).map(name => ({name, count: 2}));
        
        let suggestionsNeeded = numToSuggest;
        while(suggestionsNeeded > 0) {
            let madeSuggestion = false;
            for(const p of plan) {
                if(suggestionsNeeded <= 0) break;
                const pool = categoryPools[p.name] || [];
                if (pool.length > 0) {
                    const [suggestion] = pool.splice(Math.floor(Math.random() * pool.length), 1);
                    if(suggestion && !suggestions.has(suggestion)) {
                        suggestions.add(suggestion);
                        suggestionsNeeded--;
                        madeSuggestion = true;
                    }
                }
            }
            if(!madeSuggestion) break;
        }
        
        const suggestionsToAdd = [...suggestions].slice(0, numToSuggest);
        if (suggestionsToAdd.length > 0) {
            const separator = tagInput.value.trim().length > 0 && !tagInput.value.trim().endsWith(',') ? ', ' : '';
            tagInput.value += separator + suggestionsToAdd.join(', ').replace(/_/g, ' ');
            processAll();
        }
    }
    
    async function loadExternalTags() {
        document.title = 'Danbooru Tag Helper (Loading...)';
        try {
            const response = await fetch('tags.json');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            TAG_DATABASE = await response.json();
            console.log(`Successfully loaded ${TAG_DATABASE.length} tags.`);
            document.title = 'Danbooru Tag Helper (Ready)';
        } catch (error) {
            console.error("--- FATAL ERROR: Could not load 'tags.json' ---", error);
            document.title = 'Danbooru Tag Helper (ERROR)';
            tagInput.placeholder = "ERROR: Could not load tag database. Autocomplete is disabled.";
            TAG_DATABASE = ['error_loading_tags'];
        }
    }
    
    document.addEventListener('DOMContentLoaded', async () => {
        await loadExternalTags();
        allInputs.forEach(input => {
            const isSuggestControl = input.id.startsWith('rating-') || input.id === 'suggestionCountInput';
            if (isSuggestControl) return; // Don't trigger full process for suggestion controls

            const handler = input.tagName === 'SELECT' || input.type === 'checkbox' ? displayTags : processAll;
            input.addEventListener('change', handler);
            if(input.tagName !== 'SELECT' && input.type !== 'checkbox') input.addEventListener('input', processAll);
        });
        tagInput.addEventListener('keyup', handleAutocomplete);
        tagInput.addEventListener('keydown', handleAutocomplete);
        tagInput.addEventListener('blur', () => setTimeout(hideAutocomplete, 150));
        copyButton.addEventListener('click', copyTagsToClipboard);
        suggestBtn.addEventListener('click', suggestCoherentTags);
        themeButtons.forEach(btn => btn.addEventListener('click', () => applyTheme(btn.dataset.theme)));
        const savedTheme = localStorage.getItem('danbooru-tag-helper-theme') || 'theme-indigo';
        const savedHistory = localStorage.getItem('danbooru-tag-history');
        if (savedHistory) { copyHistory = JSON.parse(savedHistory); }
        applyTheme(savedTheme);
        processAll();
        updateCopyHistory();
    });
    </script>
</body>
</html>
</body>
</html>
