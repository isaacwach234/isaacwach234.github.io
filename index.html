<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danbooru Tag Helper Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      /* Base styles */
      body { font-family: 'Inter', sans-serif; background-color: #030712; color: #f3f4f6; }
      textarea { resize: vertical; }
      /* Highlight style */
      .highlight { background-color: #facc15; color: #111827; border-radius: 0.25rem; padding: 0 0.125rem; font-weight: 600; }
      /* Animation */
      @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
      .fade-in { animation: fadeIn 0.3s ease-out forwards; }
      /* Tag transitions */
      #tagOutput span, #triggerDisplay span, #appendDisplay span { transition: all 0.2s ease; }
      /* Icon styles */
      .icon-img { width: 1.25rem; height: 1.25rem; display: inline-block; vertical-align: middle; filter: invert(1); }
      .search-icon-img { width: 1.125rem; height: 1.125rem; filter: invert(70%) sepia(10%) saturate(200%) hue-rotate(180deg) brightness(90%) contrast(85%); }
      .copy-icon-img { width: 1rem; height: 1rem; margin-right: 0.5rem; filter: invert(1); }
      /* Count display */
      .count-display { font-size: 0.875rem; color: #6b7280; margin-left: 0.5rem; }
      /* Input/Select base */
      .input-base { border: 1px solid #374151; background-color: #1f2937; color: #f3f4f6; border-radius: 0.5rem; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); padding: 0.5rem 0.75rem; transition: all 0.15s ease-in-out; }
      .input-base:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: #2563eb; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.5); }
      .input-base::placeholder { color: #4b5563; }
      /* Checkbox base */
       .checkbox-base { height: 1rem; width: 1rem; text-blue-600 focus:ring-blue-500 border-gray-600 rounded cursor-pointer bg-gray-700; }
      /* Tag styles */
      .tag-base { font-size: 0.875rem; font-weight: 500; padding: 0.125rem 0.625rem; border-radius: 9999px; border-width: 1px; }
      .processed-tag { background-color: #1e3a8a; color: #dbeafe; border-color: #3b82f6; } /* blue */
      .trigger-tag { background-color: #581c87; color: #e9d5ff; border-color: #a855f7; } /* purple */
      .append-tag { background-color: #134e4a; color: #ccfbf1; border-color: #2dd4bf; } /* teal */
    </style>
</head>
<body class="min-h-screen p-4 md:p-8 flex items-center justify-center">

    <div class="bg-gray-900 p-8 md:p-10 rounded-xl shadow-2xl w-full max-w-4xl relative border border-gray-700">
        <h1 class="text-3xl font-bold mb-6 text-gray-100 text-center">Danbooru Tag Helper Pro</h1>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
            <div>
                <label for="tagInput" class="block text-sm font-medium text-gray-300 mb-2">
                    Enter tags (comma-separated):
                    <span id="initialTagCountDisplay" class="count-display">(Initial: 0)</span>
                </label>
                <textarea id="tagInput" rows="4" class="w-full input-base" placeholder="e.g., 1girl, solo, looking_at_viewer..."></textarea>
            </div>
            <div>
                <label for="blacklistInput" class="block text-sm font-medium text-gray-300 mb-2">Blacklist (exclude tags containing these):</label>
                <textarea id="blacklistInput" rows="4" class="w-full input-base" placeholder="e.g., bad_anatomy, blurry, text..."></textarea>
            </div>
        </div>

         <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
             <div>
                 <label for="triggerInput" class="block text-sm font-medium text-gray-300 mb-2">Prepend Trigger Words:</label>
                 <input type="text" id="triggerInput" class="w-full input-base" placeholder="e.g., trigger_word, style_prompt...">
                 <div class="mt-2 flex items-center">
                      <input id="uniquifyTriggerToggle" type="checkbox" class="checkbox-base">
                      <label for="uniquifyTriggerToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer" title="Apply simple character substitutions (e->3, s->5, etc.)">Uniquify Triggers</label>
                 </div>
             </div>
              <div>
                 <label for="appendInput" class="block text-sm font-medium text-gray-300 mb-2">Append Tags:</label>
                 <input type="text" id="appendInput" class="w-full input-base" placeholder="e.g., high_quality, best_quality...">
                 </div>
         </div>

         <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
             <div class="relative">
                 <label for="searchInput" class="block text-sm font-medium text-gray-300 mb-2">Search Tags:</label>
                 <div class="absolute inset-y-0 left-0 pl-3 pt-8 flex items-center pointer-events-none">
                     <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/search.svg" alt="Search" class="search-icon-img" />
                 </div>
                 <input type="text" id="searchInput" class="w-full pl-10 input-base" placeholder="Search tags...">
             </div>
              <div>
                  <label for="searchTargetSelect" class="block text-sm font-medium text-gray-300 mb-2">Search In:</label>
                  <select id="searchTargetSelect" class="input-base text-sm w-full">
                      <option value="processed" selected>Processed Tags (Highlight Matches)</option>
                      <option value="original">Original Input (Show Match Count Only)</option>
                  </select>
              </div>
         </div>


        <div class="flex flex-wrap items-center justify-start gap-x-6 gap-y-4 mb-8">
            <div class="flex items-center">
                <input id="underscoreToggle" type="checkbox" class="checkbox-base" checked>
                <label for="underscoreToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Use Underscores</label>
            </div>
             <div class="flex items-center">
                <input id="deduplicateToggle" type="checkbox" class="checkbox-base" checked>
                <label for="deduplicateToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Remove Duplicates</label>
            </div>
            <div>
                 <label for="sortSelect" class="block text-sm font-medium text-gray-300 sr-only">Sort Order:</label>
                 <select id="sortSelect" class="input-base text-sm">
                     <option value="smart" selected>Sort: Smart</option>
                     <option value="none">Sort: None</option>
                     <option value="az">Sort: A-Z</option>
                     <option value="za">Sort: Z-A</option>
                 </select>
            </div>
             <div>
                 <label for="maxTagsInput" class="block text-sm font-medium text-gray-300 sr-only">Max Tags:</label>
                 <input type="number" id="maxTagsInput" value="75" min="1" max="200" class="input-base text-sm w-20" aria-label="Maximum Tags">
                 <span class="text-sm text-gray-400 ml-1">Max Tags</span>
             </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                 <h3 class="text-sm font-semibold tracking-wide text-gray-400 mb-2">PREPENDED</h3>
                 <div id="triggerDisplay" class="p-3 bg-gray-800 border border-gray-700 rounded-lg min-h-[42px] flex flex-wrap gap-2">
                     <span class="text-gray-500 italic text-sm">None entered...</span>
                 </div>
            </div>
             <div>
                 <h3 class="text-sm font-semibold tracking-wide text-gray-400 mb-2">APPENDED</h3>
                 <div id="appendDisplay" class="p-3 bg-gray-800 border border-gray-700 rounded-lg min-h-[42px] flex flex-wrap gap-2">
                     <span class="text-gray-500 italic text-sm">None entered...</span>
                 </div>
            </div>
        </div>


        <div>
            <h2 id="processedTagsLabel" class="text-lg font-semibold text-gray-200 mb-3">
                Processed Tags (<span id="tagCount">0</span>/75):
                <span id="searchMatchCountDisplay" class="count-display" style="display: none;">(0 matches)</span>
            </h2>
             <p id="limitMessage" class="text-sm text-red-400 mb-3" style="display: none;">Tag limit reached.</p>
            <div id="tagOutput" class="p-4 bg-gray-800 border border-gray-700 rounded-lg min-h-[60px] flex flex-wrap gap-2">
                <span class="text-gray-400 italic">Start typing or paste tags above...</span>
            </div>
        </div>

         <div class="mt-8 text-center">
            <button id="copyButton" class="inline-flex items-center px-6 py-2.5 border border-transparent text-base font-medium rounded-lg shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-blue-500 transition-all duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed transform hover:scale-105 active:scale-95">
                <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/copy.svg" alt="Copy" class="copy-icon-img" />
                Copy All Tags
            </button>
            <p id="copyMessage" class="text-sm text-green-400 mt-2" style="display: none;">Tags copied to clipboard!</p>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const tagInput = document.getElementById('tagInput');
        const blacklistInput = document.getElementById('blacklistInput');
        const triggerInput = document.getElementById('triggerInput');
        const appendInput = document.getElementById('appendInput');
        const uniquifyTriggerToggle = document.getElementById('uniquifyTriggerToggle');
        const underscoreToggle = document.getElementById('underscoreToggle');
        const deduplicateToggle = document.getElementById('deduplicateToggle'); // New
        const searchInput = document.getElementById('searchInput');
        const searchTargetSelect = document.getElementById('searchTargetSelect');
        const sortSelect = document.getElementById('sortSelect');
        const maxTagsInput = document.getElementById('maxTagsInput');
        const triggerDisplay = document.getElementById('triggerDisplay');
        const appendDisplay = document.getElementById('appendDisplay');
        const tagOutput = document.getElementById('tagOutput');
        const initialTagCountDisplay = document.getElementById('initialTagCountDisplay');
        const limitMessage = document.getElementById('limitMessage');
        const processedTagsLabel = document.getElementById('processedTagsLabel');
        const copyButton = document.getElementById('copyButton');
        const copyMessage = document.getElementById('copyMessage');

        // --- State ---
        let originalInputTags = [];
        let baseTags = [];
        let currentBlacklist = [];
        let currentTriggers = [];
        let currentAppends = [];

        // --- Constants ---
        const UNIQUIFY_MAP = { 'a': '4', 'e': '3', 'i': '1', 'o': '0', 's': '5', 'g': '9' };
        const DEUNIQUIFY_MAP = Object.fromEntries(Object.entries(UNIQUIFY_MAP).map(([k, v]) => [v, k]));

        // --- Smart Sort Categories (lower index = higher priority) ---
        const SMART_SORT_CATEGORIES = [
            { name: 'Subject Count', keywords: ['solo', 'duo', 'trio', 'quartet', 'group'], regex: /^\d+(boy|girl)s?$/ },
            { name: 'Subject Focus', keywords: ['portrait', 'full_body', 'upper_body', 'cowboy_shot', 'face', 'close-up'] },
            { name: 'Pose/Action', keywords: ['looking_at_viewer', 'sitting', 'standing', 'lying', 'pout', 'spread_legs', 'on_back', 'leaning_forward'] },
            { name: 'Facial Expression', keywords: ['smile', 'open_mouth', 'blush', 'sad', 'angry', 'crying', 'tongue_out', 'ahegao', 'embarrassed'] },
            { name: 'Body Parts', keywords: ['breasts', 'ass', 'thighs', 'pussy', 'penis', 'navel', 'feet', 'hands'] },
            { name: 'Hair Style', regex: /.+_hair$/ }, // blue_hair, long_hair
            { name: 'Eye Color/State', regex: /.+_eyes$/ }, // blue_eyes, closed_eyes
            { name: 'Clothing', keywords: ['school_uniform', 'dress', 'shirt', 'skirt', 'pants', 'bra', 'panties', 'bikini', 'swimsuit', 'naked', 'nude', 'partially_nude'] },
            { name: 'Accessories', keywords: ['hat', 'glasses', 'ribbon', 'jewelry', 'hairband', 'choker', 'cat_ears', 'tail'] },
            { name: 'Background/Setting', keywords: ['simple_background', 'white_background', 'transparent_background', 'outdoors', 'indoors', 'night', 'day', 'cityscape', 'sky', 'room'] },
            { name: 'Art Style/Meta', keywords: ['monochrome', 'sketch', 'lineart', 'greyscale', 'comic', 'photo-realistic'] }
        ];

        // --- Functions ---

        /** Gets the priority of a tag for smart sorting. */
        function getTagPriority(tag) {
            const tagLower = tag.toLowerCase().replace(/ /g, '_');
            for (let i = 0; i < SMART_SORT_CATEGORIES.length; i++) {
                const category = SMART_SORT_CATEGORIES[i];
                if (category.keywords && category.keywords.includes(tagLower)) return i;
                if (category.regex && category.regex.test(tagLower)) return i;
            }
            return SMART_SORT_CATEGORIES.length; // Default priority for uncategorized tags
        }

        function getCurrentMaxTags() {
            const value = parseInt(maxTagsInput.value, 10);
            return isNaN(value) || value < 1 ? 75 : value;
        }

        function uniquifyWord(word) {
            return word.split('').map(char => UNIQUIFY_MAP[char.toLowerCase()] || char).join('');
        }

        function processTriggers() {
            currentTriggers = triggerInput.value.split(',').map(w => w.trim()).filter(w => w !== '');
            displayTriggers();
            displayTags(); // Triggers might affect copy button state
        }

        function displayTriggers() {
            triggerDisplay.innerHTML = '';
            const triggersToDisplay = uniquifyTriggerToggle.checked ? currentTriggers.map(uniquifyWord) : currentTriggers;
            if (triggersToDisplay.length === 0) {
                triggerDisplay.innerHTML = '<span class="text-gray-500 italic text-sm">None entered...</span>';
                return;
            }
            triggersToDisplay.forEach(trigger => {
                const el = document.createElement('span');
                el.className = 'tag-base trigger-tag fade-in';
                el.textContent = trigger;
                triggerDisplay.appendChild(el);
            });
        }

        function processAppends() {
            currentAppends = appendInput.value.split(',').map(w => w.trim()).filter(w => w !== '');
            displayAppends();
            displayTags(); // Appends might affect copy button state
        }

        function displayAppends() {
            appendDisplay.innerHTML = '';
            if (currentAppends.length === 0) {
                appendDisplay.innerHTML = '<span class="text-gray-500 italic text-sm">None entered...</span>';
                return;
            }
            currentAppends.forEach(append => {
                const el = document.createElement('span');
                el.className = 'tag-base append-tag fade-in';
                el.textContent = append;
                appendDisplay.appendChild(el);
            });
        }

        function processBlacklist() {
            currentBlacklist = blacklistInput.value.split(',').map(w => w.trim().toLowerCase()).filter(w => w !== '');
            processInput();
        }

        function processInput() {
            const rawText = tagInput.value;
            originalInputTags = rawText.replace(/[\n\s]+/g, ' ').split(',').map(t => t.trim()).filter(t => t !== '');
            initialTagCountDisplay.textContent = `(Initial: ${originalInputTags.length})`;

            let filteredTags = originalInputTags.filter(tag => {
                const tagLower = tag.toLowerCase();
                return !currentBlacklist.some(blacklistedWord => tagLower.includes(blacklistedWord));
            });

            // New: Deduplication step
            if (deduplicateToggle.checked) {
                filteredTags = [...new Set(filteredTags)];
            }

            const currentMaxTags = getCurrentMaxTags();
            baseTags = filteredTags.slice(0, currentMaxTags);
            limitMessage.style.display = filteredTags.length > currentMaxTags ? 'block' : 'none';
            displayTags();
        }

        function escapeHTML(str) {
            const p = document.createElement('p');
            p.textContent = str;
            return p.innerHTML;
        }

        function displayTags() {
            const useUnderscores = underscoreToggle.checked;
            const searchTerm = searchInput.value.trim();
            const searchTermLower = searchTerm.toLowerCase();
            const sortOrder = sortSelect.value;
            const searchTarget = searchTargetSelect.value;
            const currentMaxTags = getCurrentMaxTags();

            tagOutput.innerHTML = '';
            let displayedMatchCount = 0;
            let highlightMatches = (searchTarget === 'processed');

            processedTagsLabel.innerHTML = `Processed Tags (<span id="tagCount">${baseTags.length}</span>/${currentMaxTags}): <span id="searchMatchCountDisplay" class="count-display" style="display: none;">(0 matches)</span>`;
            const tagCountSpanInner = processedTagsLabel.querySelector('#tagCount');
            const searchMatchCountDisplayInner = processedTagsLabel.querySelector('#searchMatchCountDisplay');

            if (baseTags.length === 0 && searchTarget === 'processed') {
                 tagOutput.innerHTML = '<span class="text-gray-400 italic">Start typing or paste tags above...</span>';
                 if(tagCountSpanInner) tagCountSpanInner.textContent = '0';
                 if(searchMatchCountDisplayInner) searchMatchCountDisplayInner.style.display = 'none';
                 if (searchTarget === 'original' && searchTerm) {
                     displayedMatchCount = originalInputTags.filter(t => t.toLowerCase().includes(searchTermLower)).length;
                     if(searchMatchCountDisplayInner) {
                         searchMatchCountDisplayInner.textContent = `(${displayedMatchCount} matches in original)`;
                         searchMatchCountDisplayInner.style.display = 'inline';
                     }
                 }
                 copyButton.disabled = (currentTriggers.length === 0 && currentAppends.length === 0);
                 return;
            }

            let finalTags = baseTags.map(tag => useUnderscores ? tag.replace(/\s+/g, '_') : tag.replace(/_/g, ' '));

            if (sortOrder === 'smart') {
                finalTags.sort((a, b) => {
                    const priorityA = getTagPriority(a);
                    const priorityB = getTagPriority(b);
                    if (priorityA !== priorityB) return priorityA - priorityB;
                    return a.localeCompare(b); // Fallback to A-Z for same category
                });
            } else if (sortOrder === 'az') {
                finalTags.sort((a, b) => a.localeCompare(b));
            } else if (sortOrder === 'za') {
                finalTags.sort((a, b) => b.localeCompare(a));
            }

            finalTags.forEach(tag => {
                const tagElement = document.createElement('span');
                tagElement.className = 'tag-base processed-tag fade-in';
                const tagLower = tag.toLowerCase();
                let displayHTML = escapeHTML(tag);

                if (highlightMatches && searchTermLower && tagLower.includes(searchTermLower)) {
                    displayedMatchCount++;
                    const startIndex = tagLower.indexOf(searchTermLower);
                    const endIndex = startIndex + searchTerm.length;
                    displayHTML = escapeHTML(tag.substring(0, startIndex)) +
                                  '<span class="highlight">' + escapeHTML(tag.substring(startIndex, endIndex)) + '</span>' +
                                  escapeHTML(tag.substring(endIndex));
                }
                tagElement.innerHTML = displayHTML;
                tagOutput.appendChild(tagElement);
            });

            if (!highlightMatches && searchTermLower) {
                 displayedMatchCount = originalInputTags.filter(t => t.toLowerCase().includes(searchTermLower)).length;
            }

            if(tagCountSpanInner) tagCountSpanInner.textContent = baseTags.length.toString();
            if(searchMatchCountDisplayInner) {
                if (searchTerm) {
                    const targetLabel = searchTarget === 'original' ? ' matches in original' : ' matches';
                    searchMatchCountDisplayInner.textContent = `(${displayedMatchCount}${targetLabel})`;
                    searchMatchCountDisplayInner.style.display = 'inline';
                } else {
                    searchMatchCountDisplayInner.style.display = 'none';
                }
            }

            copyButton.disabled = (currentTriggers.length === 0 && currentAppends.length === 0 && baseTags.length === 0);
        }

        function copyTagsToClipboard() {
             if (!navigator.clipboard || !navigator.clipboard.writeText) {
                copyMessage.textContent = 'Copy failed: Browser/context insecure.';
                copyMessage.className = 'text-sm text-red-400 mt-2';
                copyMessage.style.display = 'block';
                setTimeout(() => { copyMessage.style.display = 'none'; }, 3000);
                return;
            }

            const useUnderscores = underscoreToggle.checked;
            const sortOrder = sortSelect.value;
            const shouldUniquify = uniquifyTriggerToggle.checked;

            const triggerWordsArray = shouldUniquify ? currentTriggers.map(uniquifyWord) : currentTriggers;
            
            let processedTagsArray = baseTags.map(tag => useUnderscores ? tag.replace(/\s+/g, '_') : tag.replace(/_/g, ' '));
            
            if (sortOrder === 'smart') {
                 processedTagsArray.sort((a, b) => {
                    const priorityA = getTagPriority(a);
                    const priorityB = getTagPriority(b);
                    if (priorityA !== priorityB) return priorityA - priorityB;
                    return a.localeCompare(b);
                });
            } else if (sortOrder === 'az') {
                processedTagsArray.sort((a, b) => a.localeCompare(b));
            } else if (sortOrder === 'za') {
                processedTagsArray.sort((a, b) => b.localeCompare(a));
            }

            const appendWordsArray = currentAppends;
            const combinedTags = [...triggerWordsArray, ...processedTagsArray, ...appendWordsArray];
            const tagsToCopyString = combinedTags.join(', ');

            navigator.clipboard.writeText(tagsToCopyString)
                .then(() => {
                    copyMessage.textContent = 'Tags copied to clipboard!';
                    copyMessage.className = 'text-sm text-green-400 mt-2 fade-in';
                    copyMessage.style.display = 'block';
                    setTimeout(() => copyMessage.classList.remove('fade-in'), 300);
                    setTimeout(() => { copyMessage.style.display = 'none'; }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy tags: ', err);
                    copyMessage.textContent = 'Copy failed! (See console)';
                    copyMessage.className = 'text-sm text-red-400 mt-2';
                    copyMessage.style.display = 'block';
                     setTimeout(() => { copyMessage.style.display = 'none'; }, 3000);
                });
        }

        // --- Event Listeners ---
        tagInput.addEventListener('input', processInput);
        blacklistInput.addEventListener('input', processBlacklist);
        triggerInput.addEventListener('input', processTriggers);
        appendInput.addEventListener('input', processAppends);
        uniquifyTriggerToggle.addEventListener('change', displayTriggers);
        underscoreToggle.addEventListener('change', displayTags);
        deduplicateToggle.addEventListener('change', processInput); // New
        searchInput.addEventListener('input', displayTags);
        searchTargetSelect.addEventListener('change', displayTags);
        sortSelect.addEventListener('change', displayTags);
        maxTagsInput.addEventListener('input', processInput);
        copyButton.addEventListener('click', copyTagsToClipboard);

        // --- Initial Load ---
        processTriggers();
        processAppends();
        processBlacklist();
        processInput();

    </script>

</body>
</html>
