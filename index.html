<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danbooru Tag Helper</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --accent-color: #4f46e5; /* Indigo */
        --accent-color-hover: #4338ca;
        --processed-tag-bg: rgba(79, 70, 229, 0.2);
        --processed-tag-text: rgba(199, 210, 254, 1);
        --processed-tag-border: #4f46e5;
      }
      .theme-blue {
        --accent-color: #2563eb; --accent-color-hover: #1d4ed8;
        --processed-tag-bg: rgba(37, 99, 235, 0.2); --processed-tag-text: rgba(191, 219, 254, 1); --processed-tag-border: #2563eb;
      }
      .theme-teal {
        --accent-color: #0d9488; --accent-color-hover: #0f766e;
        --processed-tag-bg: rgba(13, 148, 136, 0.2); --processed-tag-text: rgba(153, 246, 228, 1); --processed-tag-border: #0d9488;
      }
      .theme-crimson {
        --accent-color: #dc2626; --accent-color-hover: #b91c1c;
        --processed-tag-bg: rgba(220, 38, 38, 0.2); --processed-tag-text: rgba(254, 202, 202, 1); --processed-tag-border: #dc2626;
      }
      body { font-family: 'Inter', sans-serif; background-color: #111827; color: #f9fafb; }
      .main-container { background-color: #1f2937; border: 1px solid #374151; }
      .input-base { border: 1px solid #4b5563; background-color: #374151; color: #f9fafb; border-radius: 0.5rem; padding: 0.5rem 0.75rem; transition: all 0.15s ease-in-out; }
      .input-base:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: var(--accent-color); box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent-color) 50%, transparent); }
      .checkbox-base { height: 1rem; width: 1rem; border-radius: 0.25rem; cursor: pointer; background-color: #4b5563; border-color: #6b7280; color: var(--accent-color);}
      .tag-base { font-size: 0.875rem; font-weight: 500; padding: 0.25rem 0.75rem; border-radius: 9999px; border-width: 1px; display: inline-flex; align-items: center; gap: 0.5rem; cursor: grab; background-color: var(--processed-tag-bg); color: var(--processed-tag-text); border-color: var(--processed-tag-border); }
      .tag-base:active { cursor: grabbing; }
      .tag-group-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #9ca3af; margin-bottom: 0.75rem; font-weight: 600; }
      .tag-group-container { display: flex; flex-wrap: wrap; gap: 0.5rem; min-height: 38px; padding: 0.5rem; background-color: rgba(0,0,0,0.1); border-radius: 0.5rem;}
      #autocomplete-box { position: absolute; z-index: 10; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.5rem; max-height: 150px; overflow-y: auto; }
      .autocomplete-item:hover, .autocomplete-item.selected { background-color: var(--accent-color); }
      #history-container .history-item { background-color: #374151; }
      .copy-btn-sm:hover { background-color: var(--accent-color); }
      .theme-button { width: 1.25rem; height: 1.25rem; border-radius: 9999px; border: 2px solid transparent; cursor: pointer; }
      .theme-button.active { border-color: white; }
      .tag-weight-btn { font-size: 0.875rem; line-height: 1; background-color: rgba(0,0,0,0.2); border-radius: 50%; width: 1.25rem; height: 1.25rem; display: inline-flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: background-color 0.2s; border: none; color: white; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="main-container max-w-7xl mx-auto p-8 rounded-xl shadow-2xl relative">
        <div class="absolute top-4 right-4 flex items-center gap-2">
            <button class="theme-button bg-indigo-600" data-theme="theme-indigo" title="Indigo Theme"></button>
            <button class="theme-button bg-blue-600" data-theme="theme-blue" title="Blue Theme"></button>
            <button class="theme-button bg-teal-600" data-theme="theme-teal" title="Teal Theme"></button>
            <button class="theme-button bg-red-600" data-theme="theme-crimson" title="Crimson Theme"></button>
        </div>
        <h1 class="text-3xl font-bold mb-4 text-gray-100 text-center">Danbooru Tag Helper</h1>
        
        <div class="flex justify-center items-center gap-6 mb-8 text-sm text-gray-300">
            <div class="flex items-center gap-2">
                <label for="suggestionCountInput">Suggest:</label>
                <input type="number" id="suggestionCountInput" value="15" min="5" max="50" class="input-base text-sm w-20">
                <button id="suggest-btn" class="px-3 py-1 font-semibold rounded-md text-white" style="background-color: var(--accent-color); transition: background-color 0.2s;" onmouseover="this.style.backgroundColor=getComputedStyle(this).getPropertyValue('--accent-color-hover')" onmouseout="this.style.backgroundColor=getComputedStyle(this).getPropertyValue('--accent-color')">Go</button>
            </div>
            <div class="flex items-center gap-4" id="suggestion-ratings">
                <span>Ratings:</span>
                <div class="flex items-center"><input type="checkbox" id="rating-safe" class="checkbox-base" checked><label for="rating-safe" class="ml-2 cursor-pointer">Safe</label></div>
                <div class="flex items-center"><input type="checkbox" id="rating-general" class="checkbox-base" checked><label for="rating-general" class="ml-2 cursor-pointer">General</label></div>
                <div class="flex items-center"><input type="checkbox" id="rating-questionable" class="checkbox-base"><label for="rating-questionable" class="ml-2 cursor-pointer">Questionable</label></div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Left Column: Inputs -->
            <div class="lg:col-span-4 space-y-4">
                 <div>
                    <label for="tagInput" class="block text-sm font-medium text-gray-300 mb-2">Enter Tags</label>
                    <div class="relative">
                        <textarea id="tagInput" rows="6" class="w-full input-base" placeholder="1girl, solo, masterpiece, black background..."></textarea>
                        <div id="autocomplete-box" class="w-full"></div>
                    </div>
                </div>
                 <div class="grid grid-cols-2 gap-4">
                    <div>
                         <label class="block text-sm font-medium text-gray-300 mb-2">Prepend</label>
                         <input type="text" id="triggerInput" class="w-full input-base" placeholder="best quality...">
                    </div>
                    <div>
                         <label class="block text-sm font-medium text-gray-300 mb-2">Append</label>
                         <input type="text" id="appendInput" class="w-full input-base" placeholder="style_name...">
                    </div>
                </div>
                 <div>
                    <label for="swapsInput" class="block text-sm font-medium text-gray-300 mb-2">Aliases / Swaps</label>
                    <textarea id="swapsInput" rows="3" class="w-full input-base" placeholder="girl -> 1girl, boobs -> large_breasts"></textarea>
                 </div>
                 <div>
                    <label for="implicationsInput" class="block text-sm font-medium text-gray-300 mb-2">Implications</label>
                    <textarea id="implicationsInput" rows="3" class="w-full input-base" placeholder="1girl => backlighting"></textarea>
                 </div>
                 <div>
                    <label for="blacklistInput" class="block text-sm font-medium text-gray-300 mb-2">Blacklist</label>
                    <textarea id="blacklistInput" rows="2" class="w-full input-base" placeholder="bad_anatomy, blurry, text"></textarea>
                 </div>
            </div>

            <!-- Center Column: Processed Tags -->
            <div class="lg:col-span-5">
                <div class="flex flex-wrap items-center justify-between gap-4 mb-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
                     <div class="flex items-center gap-x-6 gap-y-2 flex-wrap">
                        <div class="flex items-center">
                            <input id="deduplicateToggle" type="checkbox" class="checkbox-base" checked>
                            <label for="deduplicateToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Deduplicate</label>
                        </div>
                        <div class="flex items-center">
                            <input id="underscoreToggle" type="checkbox" class="checkbox-base" checked>
                            <label for="underscoreToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Use_Underscores</label>
                        </div>
                         <div class="flex items-center">
                            <input id="enableWeightingToggle" type="checkbox" class="checkbox-base">
                            <label for="enableWeightingToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Enable Weighting</label>
                        </div>
                     </div>
                     <div class="flex items-center gap-x-4">
                         <select id="sortSelect" class="input-base text-sm">
                             <option value="danbooru" selected>Sort: Danbooru</option>
                             <option value="manual">Sort: Manual</option>
                             <option value="none">Sort: None</option>
                             <option value="az">Sort: A-Z</option>
                             <option value="za">Sort: Z-A</option>
                         </select>
                         <input type="number" id="maxTagsInput" value="75" min="1" max="500" class="input-base text-sm w-20" aria-label="Maximum Tags">
                    </div>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                         <h2 id="processedTagsLabel" class="text-lg font-semibold text-gray-200">
                            Processed Tags (<span id="tagCount">0</span>/<span id="maxTagCount">75</span>)
                        </h2>
                    </div>
                    <div id="tagOutput" class="p-4 bg-gray-900/50 border border-gray-700 rounded-lg min-h-[400px] space-y-4">
                        <span class="text-gray-500 italic">Start typing or paste tags above...</span>
                    </div>
                </div>
                 <div class="mt-4">
                    <button id="copyButton" class="w-full inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-lg shadow-sm text-white disabled:opacity-50 disabled:cursor-not-allowed" style="background-color: var(--accent-color);">
                        Copy All Tags
                    </button>
                    <p id="copyMessage" class="text-sm text-green-400 mt-2 h-5 text-center"></p>
                </div>
            </div>
            
            <!-- Right Column: History -->
            <div class="lg:col-span-3">
                 <h3 class="text-lg font-semibold tracking-wide text-gray-200 mb-4">Copy History</h3>
                 <div id="history-container" class="space-y-2">
                     <p class="text-sm text-gray-500 italic">No history yet.</p>
                 </div>
            </div>
        </div>
    </div>

    <script>
    let TAG_DATABASE = [];
    let tagIdCounter = 0;

    const QUESTIONABLE_KEYWORDS = ['bikini', 'swimsuit', 'cleavage', 'breasts', 'ass', 'thighs', 'pantyhose', 'leotard', 'garter_belt', 'panty_shot', 'sideboob', 'topless', 'bra', 'panties', 'lingerie', 'seductive', 'bondage', 'shibari', 'partially_nude', 'armpits', 'bottomless'];
    const EXPLICIT_KEYWORDS = ['pussy', 'penis', 'sex', 'oral', 'ahegao', 'nude', 'naked', 'cum', 'masturbation', 'fellatio', 'cunnilingus', 'prolapse'];
    
    // --- NEW: More specific, granular categories for accurate sorting ---
    const TAG_CATEGORIES = [
        { name: 'Quality', keywords: ['masterpiece', 'best quality', 'highres', 'absurdres', '4k', '8k', 'extremely detailed', 'best quality'] },
        { name: 'Composition', keywords: ['solo', '1girl', '1boy', '2girls', 'duo', 'trio', 'group', 'portrait', 'full body', 'upper body', 'cowboy shot', 'close-up', 'from side', 'from behind', 'from above', 'from below', 'profile', 'dutch angle', 'wide shot', 'upper_body'] },
        { name: 'Subject & Creatures', keywords: ['hatsune miku', 'gawr gura', 'rem (re:zero)', 'remilia scarlet', 'ganyu (genshin impact)', 'hu tao (genshin impact)', 'raiden shogun (genshin impact)', 'yae miko (genshin impact)', 'flandre scarlet', 'cirno', 'hakurei reimu', 'monika (doki doki literature club!)', 'tokisaki kurumi', 'honshou kaede', 'zero two (darling in the franxx)', 'hololive', 'genshin impact', 'touhou', 'kantai collection', 'azur lane', 'fate/grand order', 'the idolm@ster', 'original', 'monster girl', 'slime girl', 'personification'] },
        { name: 'Face', keywords: [':d', ':3', 'blush', 'closed mouth', 'open mouth', 'smile', 'face', 'facial mark', 'fangs', 'lips', 'nose', 'parted bangs', 'short eyebrows', 'bags under eyes', 'blush stickers', 'one eye closed', 'pout', 'tongue', 'green tongue', 'colored tongue'] },
        { name: 'Eyes', keywords: ['closed eyes', 'eyelashes', 'eyes', 'blue eyes', 'red eyes', 'green eyes', 'brown eyes', 'purple eyes', 'yellow eyes', 'orange eyes', 'aqua eyes', 'hair between eyes'] },
        { name: 'Hair', keywords: ['ahoge', 'hair', 'blonde hair', 'long hair', 'brown hair', 'black hair', 'short hair', 'white hair', 'silver hair', 'pink hair', 'purple hair', 'blue hair', 'red hair', 'green hair', 'orange hair', 'grey hair', 'hair between eyes', 'very long hair', 'multicolored hair', 'streaked hair', 'two-tone hair', 'braid', 'colored inner hair'] },
        { name: 'Body Parts', keywords: ['breasts', 'large breasts', 'medium breasts', 'small breasts', 'collarbone', 'ears', 'cat ears', 'elf ears', 'pointy ears', 'hands', 'head', 'horns', 'navel', 'skin', 'pale skin', 'dark skin', 'tan', 'thighs', 'wings', 'chibi', 'colored skin', 'yellow skin'] },
        { name: 'Attire', keywords: ['apron', 'armor', 'bandaid', 'bare shoulders', 'barefoot', 'bloomers', 'boots', 'cape', 'cleavage', 'cleavage cutout', 'clothing', 'coat', 'dress', 'japanese clothes', 'kimono', 'leotard', 'lingerie', 'miniskirt', 'navel cutout', 'pantyhose', 'panties', 'puffy sleeves', 'school uniform', 'seifuku', 'serafuku', 'shirt', 'white shirt', 'collared shirt', 'shoes', 'sneakers', 'shorts', 'skirt', 'sleeveless', 'slippers', 'socks', 'stockings', 'suit', 'sweater', 'swimsuit', 'turtleneck', 'uniform', 'zettai ryouiki', 'hood', 'hood down', 'hooded jacket', 'pink jacket', 'jacket', 'sleeves', 'long sleeves', 'sleeves past wrists', 'bottomless'] },
        { name: 'Accessories', keywords: ['animal ears', 'bell', 'belt', 'bow', 'bracelet', 'chain', 'choker', 'red choker', 'collar', 'crown', 'detached sleeves', 'earrings', 'elbow gloves', 'eyewear', 'frills', 'glasses', 'gloves', 'goggles', 'hair ornament', 'hairband', 'hairpin', 'hat', 'headband', 'headphones', 'headdress', 'hoodie', 'jewelry', 'maid headdress', 'mask', 'necklace', 'neckerchief', 'necktie', 'ribbon', 'tie'] },
        { name: 'Held Items & Objects', keywords: ['holding', 'weapon', 'sword', 'gun', 'chopsticks', 'holding chopsticks', 'food', 'cup ramen', 'nissin cup noodle', 'stuffed animal', 'stuffed toy', 'hugging doll', 'hugging object', 'stuffed cat', 'liquid hair'] },
        { name: 'Actions & Poses', keywords: ['ass grab', 'bending over', 'crossed arms', 'crouching', 'dancing', 'fighting', 'fingers in mouth', 'flying', 'hand in own hair', 'hands on hips', 'hands up', 'hugging', 'animal hug', 'jumping', 'kicking', 'kissing', 'kneeling', 'leaning forward', 'licking', 'lying', 'on back', 'on stomach', 'pointing', 'punching', 'reaching', 'running', 'sitting', 'sleeping', 'spread arms', 'spread legs', 'standing', 'stretching', 'waving', 'yawning', 'looking at viewer', 'looking away', 'looking back', 'looking down', 'looking up', 'eating'] },
        { name: 'Setting & Environment', keywords: ['indoors', 'outdoors', 'background', 'simple background', 'white background', 'black background', 'colored background', 'grey background', 'transparent background', 'gradient background', 'blurry background', 'beach', 'bed', 'building', 'chair', 'city', 'clouds', 'day', 'desk', 'forest', 'moon', 'nature', 'night', 'ocean', 'park', 'rain', 'river', 'road', 'room', 'school', 'sea', 'sky', 'snow', 'stars', 'street', 'sun', 'sunset', 'tree', 'underwater', 'water', 'window', 'pink background', 'scenery'] },
        { name: 'Style & Meta', keywords: ['2d', '3d', 'absurdres', 'artbook', 'artist name', 'bad anatomy', 'bad artist', 'bad hands', 'bad id', 'bad pixiv id', 'bad twitter id', 'bad uri', 'comic', 'commentary', 'commentary request', 'conditional parent', 'deletethis', 'drawing', 'extra digits', 'fanart', 'greyscale', 'hi res', 'jpeg artifacts', 'lineart', 'low res', 'monochrome', 'photo', 'pixel art', 'realistic', 'scanned', 'signature', 'sketch', 'tagme', 'text', 'traditional media', 'translation request', 'watermark', 'web bro', 'heart', 'backlighting', 'steam', '(steaming food:1.2)', 'wariza', 'faux traditional media', 'painting (medium)'] }
    ];

    const element = (id) => document.getElementById(id);
    const body = document.body;
    const allInputs = document.querySelectorAll('input, textarea, select');
    const tagInput = element('tagInput'), swapsInput = element('swapsInput'), implicationsInput = element('implicationsInput'), blacklistInput = element('blacklistInput'), triggerInput = element('triggerInput'), appendInput = element('appendInput');
    const deduplicateToggle = element('deduplicateToggle'), underscoreToggle = element('underscoreToggle'), enableWeightingToggle = element('enableWeightingToggle');
    const sortSelect = element('sortSelect'), maxTagsInput = element('maxTagsInput'), tagOutput = element('tagOutput'), processedTagsLabel = element('processedTagsLabel');
    const copyButton = element('copyButton'), copyMessage = element('copyMessage'), historyContainer = element('history-container'), autocompleteBox = element('autocomplete-box');
    const suggestBtn = element('suggest-btn'), themeButtons = document.querySelectorAll('.theme-button'), suggestionCountInput = element('suggestionCountInput');
    const ratingSafe = element('rating-safe'), ratingGeneral = element('rating-general'), ratingQuestionable = element('rating-questionable');
    
    let baseTags = [], copyHistory = [], autocomplete = { active: false, index: -1, currentWord: '' }, sortableInstances = [];
    
    function processAll() {
        const swaps = new Map(swapsInput.value.split(',').map(s => s.split('->').map(p => p.trim())).filter(p => p.length === 2 && p[0]));
        const implications = new Map(implicationsInput.value.split(',').map(s => s.split('=>').map(p => p.trim())).filter(p => p.length === 2 && p[0]));
        const blacklist = new Set(blacklistInput.value.replace(/[\n\s]+/g, ',').split(',').map(w => w.trim().toLowerCase()).filter(Boolean));
        let rawTags = tagInput.value.replace(/[\n]+/g, ',').split(',').map(t => t.trim()).filter(Boolean);
        rawTags = rawTags.map(tag => swaps.get(tag.toLowerCase().replace(/_/g, ' ')) || tag);
        const tagsToAdd = new Set();
        rawTags.forEach(tag => {
            const lowerTag = tag.toLowerCase();
            if (implications.has(lowerTag)) implications.get(lowerTag).split(',').forEach(imp => tagsToAdd.add(imp.trim()));
        });
        rawTags = [...rawTags, ...tagsToAdd];
        if (deduplicateToggle.checked) {
            const seen = new Set();
            rawTags = rawTags.filter(tag => {
                const lower = tag.toLowerCase().replace(/_/g, ' ');
                if (seen.has(lower)) return false;
                seen.add(lower); return true;
            });
        }
        let filteredTags = rawTags.filter(tag => ![...blacklist].some(b => tag.toLowerCase().includes(b)));
        const maxTags = parseInt(maxTagsInput.value, 10) || 75;
        const newBaseTags = [];
        const existingTagsMap = new Map(baseTags.map(t => [t.original, t]));
        filteredTags.slice(0, maxTags).forEach(tag => {
            if (existingTagsMap.has(tag)) newBaseTags.push(existingTagsMap.get(tag));
            else newBaseTags.push({ original: tag, weighted: tag, id: `tag-${tagIdCounter++}` });
        });
        if (!enableWeightingToggle.checked) newBaseTags.forEach(t => t.weighted = t.original);
        baseTags = newBaseTags;
        displayTags();
    }

    function displayTags() {
        processedTagsLabel.querySelector('#tagCount').textContent = baseTags.length;
        processedTagsLabel.querySelector('#maxTagCount').textContent = maxTagsInput.value;
        tagOutput.innerHTML = '';
        if (baseTags.length === 0) {
            tagOutput.innerHTML = '<span class="text-gray-500 italic">Start typing or paste tags above...</span>';
            copyButton.disabled = true; return;
        }
        const sortOrder = sortSelect.value;
        let tagsToDisplay = [...baseTags];
        if (sortOrder === 'danbooru') {
            const groups = tagsToDisplay.reduce((acc, tag) => {
                const categoryName = getTagCategoryName(tag);
                if (!acc[categoryName]) acc[categoryName] = [];
                acc[categoryName].push(tag);
                return acc;
            }, {});
            const sortedCategoryNames = TAG_CATEGORIES.map(c => c.name).filter(name => groups[name]);
            if (groups['Other']) sortedCategoryNames.push('Other');
            sortedCategoryNames.forEach(categoryName => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'tag-group';
                groupDiv.innerHTML = `<h3 class="tag-group-title">${categoryName}</h3>`;
                const container = document.createElement('div');
                container.className = 'tag-group-container';
                container.dataset.groupName = categoryName;
                groups[categoryName].forEach(tag => container.appendChild(createTagElement(tag)));
                groupDiv.appendChild(container);
                tagOutput.appendChild(groupDiv);
            });
        } else {
            if (sortOrder === 'az') tagsToDisplay.sort((a, b) => a.original.localeCompare(b.original));
            else if (sortOrder === 'za') tagsToDisplay.sort((a, b) => b.original.localeCompare(a.original));
            const container = document.createElement('div');
            container.className = 'tag-group-container';
            container.dataset.groupName = 'all';
            tagsToDisplay.forEach(tag => container.appendChild(createTagElement(tag)));
            tagOutput.appendChild(container);
        }
        copyButton.disabled = false;
        initSortable();
    }
    
    function createTagElement(tag) {
        const el = document.createElement('div');
        el.className = 'tag-base processed-tag';
        el.dataset.id = tag.id;
        const useUnderscores = underscoreToggle.checked;
        const displayTag = useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' ');
        if (enableWeightingToggle.checked) {
            el.style.paddingLeft = '0.375rem';
            el.oncontextmenu = (e) => {
                e.preventDefault();
                const weightVal = tag.weighted.match(/:(\d\.\d+)\)$/)?.[1] || '1.1';
                const newWeight = prompt(`Enter weight for "${tag.original}" (e.g., 1.1):`, weightVal);
                if (newWeight && !isNaN(parseFloat(newWeight))) {
                    tag.weighted = `(${tag.original}:${newWeight})`; displayTags();
                }
            };
            el.innerHTML = `<button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'decrease')" title="Decrease weight">-</button><span class="tag-text px-1">${displayTag}</span><button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'increase')" title="Increase weight">+</button>`;
        } else {
            el.innerHTML = `<span class="tag-text">${displayTag}</span>`;
        }
        return el;
    }

    window.updateTagWeight = (id, action) => {
        const tag = baseTags.find(t => t.id === id); if (!tag) return;
        let current = tag.weighted; const original = tag.original;
        if (action === 'increase') {
            if (current.startsWith('((')) current = `(((${original})))`;
            else if (current.startsWith('(')) current = `((${original}))`;
            else if (current.startsWith('[')) current = original;
            else current = `(${original})`;
        } else {
            if (current.startsWith('[[')) current = `[[[${original}]]]`;
            else if (current.startsWith('[')) current = `[[${original}]]`;
            else if (current.startsWith('(')) current = original;
            else current = `[${original}]`;
        }
        tag.weighted = current; displayTags();
    };

    function getTagCategoryName(tag) {
        const tagWithSpaces = (tag.original || tag).toLowerCase().replace(/_/g, ' ');
        for (const category of TAG_CATEGORIES) {
            if (category.keywords.includes(tagWithSpaces)) return category.name;
        }
        return 'Other';
    }

    function initSortable() {
        if (sortableInstances.length) sortableInstances.forEach(s => s.destroy());
        sortableInstances = [];
        const containers = tagOutput.querySelectorAll('.tag-group-container');
        containers.forEach(container => {
            const s = new Sortable(container, {
                group: 'shared', animation: 150, ghostClass: 'opacity-50',
                onEnd: () => {
                    sortSelect.value = 'manual';
                    const allTagElements = Array.from(tagOutput.querySelectorAll('.tag-base'));
                    baseTags = allTagElements.map(el => baseTags.find(t => t.id === el.dataset.id)).filter(Boolean);
                },
            });
            sortableInstances.push(s);
        });
    }

    // --- MODIFIED: Added 'Tab' key logic ---
    function handleAutocomplete(e) {
        const text = tagInput.value; const cursorPos = tagInput.selectionStart;
        const lastComma = text.lastIndexOf(',', cursorPos - 1);
        autocomplete.currentWord = text.substring(lastComma + 1, cursorPos).trim();

        if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter' || e.key === 'Tab') {
            if (!autocomplete.active) return;
            e.preventDefault();

            if (e.key === 'Enter' || e.key === 'Tab') {
                if (autocomplete.index === -1) autocomplete.index = 0; // Default to first item if none selected
                if (autocomplete.suggestions[autocomplete.index]) {
                    selectAutocompleteItem(autocomplete.suggestions[autocomplete.index]);
                }
                return;
            }
            
            if (e.key === 'ArrowDown') autocomplete.index = (autocomplete.index + 1) % autocomplete.suggestions.length;
            if (e.key === 'ArrowUp') autocomplete.index = (autocomplete.index - 1 + autocomplete.suggestions.length) % autocomplete.suggestions.length;
            updateAutocompleteSelection();
            return;
        }

        if (!autocomplete.currentWord) { hideAutocomplete(); return; }
        autocomplete.suggestions = TAG_DATABASE.filter(t => t.startsWith(autocomplete.currentWord.replace(/ /g, '_'))).slice(0, 5);
        if (autocomplete.suggestions.length > 0) {
            autocomplete.active = true; autocomplete.index = -1; renderAutocomplete();
        } else {
            hideAutocomplete();
        }
    }

    function renderAutocomplete() {
        autocompleteBox.innerHTML = autocomplete.suggestions.map((s, i) => `<div class="autocomplete-item p-2 cursor-pointer ${i === autocomplete.index ? 'selected' : ''}" onmousedown="selectAutocompleteItem('${s}')">${s.replace(/_/g, ' ')}</div>`).join('');
        autocompleteBox.style.display = 'block';
    }

    function updateAutocompleteSelection() {
        Array.from(autocompleteBox.children).forEach((child, i) => child.classList.toggle('selected', i === autocomplete.index));
    }

    window.selectAutocompleteItem = (tag) => {
        const text = tagInput.value; const cursorPos = tagInput.selectionStart;
        const lastComma = text.lastIndexOf(',', cursorPos - 1);
        const before = text.substring(0, lastComma + 1);
        tagInput.value = `${before} ${tag.replace(/_/g, ' ')}, ${text.substring(cursorPos)}`;
        hideAutocomplete(); tagInput.focus(); processAll();
    };

    function hideAutocomplete() {
        autocomplete.active = false; autocompleteBox.style.display = 'none';
    }
    
    function copyTagsToClipboard() {
        const useUnderscores = underscoreToggle.checked;
        const triggers = triggerInput.value.split(',').map(t => t.trim()).filter(Boolean);
        const appends = appendInput.value.split(',').map(t => t.trim()).filter(Boolean);
        const processed = baseTags.map(tag => useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' '));
        const finalString = [...triggers, ...processed, ...appends].join(', ');
        navigator.clipboard.writeText(finalString).then(() => {
            copyMessage.textContent = 'Tags copied!';
            updateCopyHistory(finalString);
            setTimeout(() => copyMessage.textContent = '', 2000);
        }).catch(err => copyMessage.textContent = 'Copy failed!');
    }

    function updateCopyHistory(text) {
        if(text){ copyHistory.unshift(text); if (copyHistory.length > 10) copyHistory.pop(); localStorage.setItem('danbooru-tag-history', JSON.stringify(copyHistory)); }
        historyContainer.innerHTML = '';
        if (copyHistory.length === 0) { historyContainer.innerHTML = `<p class="text-sm text-gray-500 italic">No history yet.</p>`; return; }
        copyHistory.forEach(item => {
            const el = document.createElement('div');
            el.className = 'history-item p-2 rounded-md flex items-center justify-between gap-2';
            el.innerHTML = `<span class="history-item-text text-gray-400 text-xs flex-grow overflow-hidden whitespace-nowrap text-ellipsis">${item}</span><button class="copy-btn-sm p-1 rounded" onclick="navigator.clipboard.writeText(\`${item.replace(/`/g, '\\`')}\`)"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>`;
            historyContainer.appendChild(el);
        });
    }

    function applyTheme(theme) {
        body.className = `p-4 md:p-8 ${theme}`; themeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.theme === theme)); localStorage.setItem('danbooru-tag-helper-theme', theme);
    }

    function suggestCoherentTags() {
        if (TAG_DATABASE.length < 2) return;
        const numToSuggest = parseInt(suggestionCountInput.value, 10);
        const existingTags = new Set(baseTags.map(t => t.original.toLowerCase().replace(/ /g, '_')));
        const isAllowed = (tag) => {
            if (EXPLICIT_KEYWORDS.some(kw => tag.includes(kw))) return false;
            if (!ratingQuestionable.checked && QUESTIONABLE_KEYWORDS.some(kw => tag.includes(kw))) return false;
            if (!ratingGeneral.checked && !ratingSafe.checked) return false;
            return true;
        };
        const suggestions = new Set();
        const categoryPools = {};
        TAG_CATEGORIES.forEach(c => categoryPools[c.name] = []);
        for (const tag of TAG_DATABASE) {
            if (existingTags.has(tag) || !isAllowed(tag)) continue;
            const categoryName = getTagCategoryName({ original: tag });
            if (categoryPools[categoryName]) categoryPools[categoryName].push(tag);
        }

        const plan = (existingTags.size === 0) 
            ? [ { name: 'Quality', count: 1 }, { name: 'Composition', count: 2 }, { name: 'Subject & Creatures', count: 1 }, { name: 'Face', count: 2 }, { name: 'Eyes', count: 1 }, { name: 'Hair', count: 2 }, { name: 'Body Parts', count: 1 }, { name: 'Attire', count: 1 }, { name: 'Actions & Poses', count: 2 }, { name: 'Setting & Environment', count: 2 } ]
            : Object.entries(baseTags.reduce((acc, tag) => { acc[getTagCategoryName(tag)] = (acc[getTagCategoryName(tag)] || 0) + 1; return acc; }, {})).map(([name, count]) => ({name, count}));
        
        let suggestionsNeeded = numToSuggest;
        while(suggestionsNeeded > 0) {
            let madeSuggestion = false;
            for(const p of plan) {
                if(suggestionsNeeded <= 0) break;
                const pool = categoryPools[p.name] || [];
                for(let i=0; i < p.count; ++i) {
                     if(pool.length > 0) {
                        const [suggestion] = pool.splice(Math.floor(Math.random() * pool.length), 1);
                        if(suggestion && !suggestions.has(suggestion)) {
                            suggestions.add(suggestion);
                            suggestionsNeeded--;
                            madeSuggestion = true;
                        }
                    }
                }
            }
            if(!madeSuggestion) break;
        }
        
        const suggestionsToAdd = [...suggestions];
        if (suggestionsToAdd.length > 0) {
            const separator = tagInput.value.trim().length > 0 && !tagInput.value.trim().endsWith(',') ? ', ' : '';
            tagInput.value += separator + suggestionsToAdd.join(', ').replace(/_/g, ' ');
            processAll();
        }
    }
    
    async function loadExternalTags() {
        document.title = 'Danbooru Tag Helper (Loading...)';
        try {
            const response = await fetch('tags.json');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            TAG_DATABASE = await response.json();
            console.log(`Successfully loaded ${TAG_DATABASE.length} tags.`);
            document.title = 'Danbooru Tag Helper (Ready)';
        } catch (error) {
            console.error("--- FATAL ERROR: Could not load 'tags.json' ---", error);
            document.title = 'Danbooru Tag Helper (ERROR)';
            tagInput.placeholder = "ERROR: Could not load tag database. Autocomplete is disabled.";
            TAG_DATABASE = ['error_loading_tags'];
        }
    }
    
    document.addEventListener('DOMContentLoaded', async () => {
        await loadExternalTags();
        allInputs.forEach(input => {
            const isSuggestControl = input.id.startsWith('rating-') || input.id === 'suggestionCountInput';
            if (isSuggestControl) return;
            const handler = input.tagName === 'SELECT' || input.type === 'checkbox' ? displayTags : processAll;
            input.addEventListener('change', handler);
            if(input.tagName !== 'SELECT' && input.type !== 'checkbox') input.addEventListener('input', processAll);
        });
        tagInput.addEventListener('keyup', handleAutocomplete);
        tagInput.addEventListener('keydown', handleAutocomplete); // Keydown is important for Tab
        tagInput.addEventListener('blur', () => setTimeout(hideAutocomplete, 150));
        copyButton.addEventListener('click', copyTagsToClipboard);
        suggestBtn.addEventListener('click', suggestCoherentTags);
        themeButtons.forEach(btn => btn.addEventListener('click', () => applyTheme(btn.dataset.theme)));
        const savedTheme = localStorage.getItem('danbooru-tag-helper-theme') || 'theme-indigo';
        const savedHistory = localStorage.getItem('danbooru-tag-history');
        if (savedHistory) copyHistory = JSON.parse(savedHistory);
        applyTheme(savedTheme);
        processAll();
        updateCopyHistory();
    });
    </script>
</body>
</html>
