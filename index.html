<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danbooru Tag Helper Final</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --accent-color: #4f46e5; /* Indigo */
        --accent-color-hover: #4338ca;
        --processed-tag-bg: rgba(79, 70, 229, 0.2);
        --processed-tag-text: rgba(199, 210, 254, 1);
        --processed-tag-border: #4f46e5;
      }
      .theme-blue {
        --accent-color: #2563eb; --accent-color-hover: #1d4ed8;
        --processed-tag-bg: rgba(37, 99, 235, 0.2); --processed-tag-text: rgba(191, 219, 254, 1); --processed-tag-border: #2563eb;
      }
      .theme-teal {
        --accent-color: #0d9488; --accent-color-hover: #0f766e;
        --processed-tag-bg: rgba(13, 148, 136, 0.2); --processed-tag-text: rgba(153, 246, 228, 1); --processed-tag-border: #0d9488;
      }
      .theme-crimson {
        --accent-color: #dc2626; --accent-color-hover: #b91c1c;
        --processed-tag-bg: rgba(220, 38, 38, 0.2); --processed-tag-text: rgba(254, 202, 202, 1); --processed-tag-border: #dc2626;
      }
      body { font-family: 'Inter', sans-serif; background-color: #111827; color: #f9fafb; }
      .main-container { background-color: #1f2937; border: 1px solid #374151; }
      .input-base { border: 1px solid #4b5563; background-color: #374151; color: #f9fafb; border-radius: 0.5rem; padding: 0.5rem 0.75rem; transition: all 0.15s ease-in-out; }
      .input-base:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: var(--accent-color); box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent-color) 50%, transparent); }
      .checkbox-base { height: 1rem; width: 1rem; border-radius: 0.25rem; cursor: pointer; background-color: #4b5563; border-color: #6b7280; color: var(--accent-color);}
      .tag-base { font-size: 0.875rem; font-weight: 500; padding: 0.25rem 0.375rem 0.25rem 0.75rem; border-radius: 9999px; border-width: 1px; display: inline-flex; align-items: center; gap: 0.5rem; cursor: grab; background-color: var(--processed-tag-bg); color: var(--processed-tag-text); border-color: var(--processed-tag-border); }
      .tag-base:active { cursor: grabbing; }
      .tag-group-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #9ca3af; margin-bottom: 0.75rem; font-weight: 600; }
      .tag-group-container { display: flex; flex-wrap: wrap; gap: 0.5rem; min-height: 38px;}
      #autocomplete-box { position: absolute; z-index: 10; background-color: #374151; border: 1px solid #4b5563; border-radius: 0.5rem; max-height: 150px; overflow-y: auto; }
      .autocomplete-item:hover, .autocomplete-item.selected { background-color: var(--accent-color); }
      #history-container .history-item { background-color: #374151; }
      .copy-btn-sm:hover { background-color: var(--accent-color); }
      .theme-button { width: 1.25rem; height: 1.25rem; border-radius: 9999px; border: 2px solid transparent; cursor: pointer; }
      .theme-button.active { border-color: white; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="main-container max-w-7xl mx-auto p-8 rounded-xl shadow-2xl relative">
        <div class="absolute top-4 right-4 flex items-center gap-2">
            <button class="theme-button bg-indigo-600" data-theme="theme-indigo" title="Indigo Theme"></button>
            <button class="theme-button bg-blue-600" data-theme="theme-blue" title="Blue Theme"></button>
            <button class="theme-button bg-teal-600" data-theme="theme-teal" title="Teal Theme"></button>
            <button class="theme-button bg-red-600" data-theme="theme-crimson" title="Crimson Theme"></button>
        </div>
        <h1 class="text-3xl font-bold mb-8 text-gray-100 text-center">Danbooru Tag Helper</h1>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Left Column: Inputs -->
            <div class="lg:col-span-4 space-y-4">
                 <div>
                    <div class="flex justify-between items-center mb-2">
                         <label for="tagInput" class="block text-sm font-medium text-gray-300">Enter Tags</label>
                         <button id="suggest-btn" class="text-sm font-semibold text-gray-400 hover:text-white transition-colors">Suggest</button>
                    </div>
                    <div class="relative">
                        <textarea id="tagInput" rows="6" class="w-full input-base" placeholder="1girl, solo, masterpiece..."></textarea>
                        <div id="autocomplete-box" class="w-full"></div>
                    </div>
                </div>
                 <div class="grid grid-cols-2 gap-4">
                    <div>
                         <label class="block text-sm font-medium text-gray-300 mb-2">Prepend</label>
                         <input type="text" id="triggerInput" class="w-full input-base" placeholder="best quality...">
                    </div>
                    <div>
                         <label class="block text-sm font-medium text-gray-300 mb-2">Append</label>
                         <input type="text" id="appendInput" class="w-full input-base" placeholder="style_name...">
                    </div>
                </div>
                 <div>
                    <label for="swapsInput" class="block text-sm font-medium text-gray-300 mb-2">Aliases / Swaps</label>
                    <textarea id="swapsInput" rows="3" class="w-full input-base" placeholder="girl -> 1girl, boobs -> large_breasts"></textarea>
                 </div>
                 <div>
                    <label for="implicationsInput" class="block text-sm font-medium text-gray-300 mb-2">Implications</label>
                    <textarea id="implicationsInput" rows="3" class="w-full input-base" placeholder="2girls => duo, uniform => clothing"></textarea>
                 </div>
                 <div>
                    <label for="blacklistInput" class="block text-sm font-medium text-gray-300 mb-2">Blacklist</label>
                    <textarea id="blacklistInput" rows="2" class="w-full input-base" placeholder="bad_anatomy, blurry, text"></textarea>
                 </div>
            </div>

            <!-- Center Column: Processed Tags -->
            <div class="lg:col-span-5">
                <div class="flex flex-wrap items-center justify-between gap-4 mb-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
                     <div class="flex items-center gap-x-6 gap-y-2 flex-wrap">
                        <div class="flex items-center">
                            <input id="deduplicateToggle" type="checkbox" class="checkbox-base" checked>
                            <label for="deduplicateToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Deduplicate</label>
                        </div>
                        <div class="flex items-center">
                            <input id="underscoreToggle" type="checkbox" class="checkbox-base" checked>
                            <label for="underscoreToggle" class="ml-2 block text-sm text-gray-300 cursor-pointer">Use_Underscores</label>
                        </div>
                     </div>
                     <div class="flex items-center gap-x-4">
                         <select id="sortSelect" class="input-base text-sm">
                             <option value="smart" selected>Sort: Smart</option>
                             <option value="manual">Sort: Manual</option>
                             <option value="none">Sort: None</option>
                             <option value="az">Sort: A-Z</option>
                             <option value="za">Sort: Z-A</option>
                         </select>
                         <input type="number" id="maxTagsInput" value="75" min="1" max="500" class="input-base text-sm w-20" aria-label="Maximum Tags">
                    </div>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                         <h2 id="processedTagsLabel" class="text-lg font-semibold text-gray-200">
                            Processed Tags (<span id="tagCount">0</span>/<span id="maxTagCount">75</span>)
                        </h2>
                    </div>
                    <div id="tagOutput" class="p-4 bg-gray-900/50 border border-gray-700 rounded-lg min-h-[400px]">
                        <span class="text-gray-500 italic">Start typing or paste tags above...</span>
                    </div>
                </div>
                 <div class="mt-4">
                    <button id="copyButton" class="w-full inline-flex items-center justify-center px-6 py-3 border border-transparent text-base font-medium rounded-lg shadow-sm text-white disabled:opacity-50 disabled:cursor-not-allowed" style="background-color: var(--accent-color);">
                        Copy All Tags
                    </button>
                    <p id="copyMessage" class="text-sm text-green-400 mt-2 h-5 text-center"></p>
                </div>
            </div>
            
            <!-- Right Column: History -->
            <div class="lg:col-span-3">
                 <h3 class="text-lg font-semibold tracking-wide text-gray-200 mb-4">Copy History</h3>
                 <div id="history-container" class="space-y-2">
                     <p class="text-sm text-gray-500 italic">No history yet.</p>
                 </div>
            </div>
        </div>
    </div>

    <script>
    // --- Constants and State --- (Tag DB is abridged for brevity)
    const TAG_DATABASE = ["1girl", "solo", "long_hair", "blush", "smile", "looking_at_viewer", "short_hair", "breasts", "open_mouth", "blue_eyes", "skirt", "multiple_girls", "brown_hair", "blonde_hair", "black_hair", "2girls", "school_uniform", "red_eyes", "twintails", "dress", "very_long_hair", "hat", "ribbon", "closed_eyes", "thighhighs", "bangs", "hair_ornament", "gloves", "full_body", "bare_shoulders", "white_hair", "long_sleeves", "shirt", "bow", "green_eyes", "hair_ribbon", "cleavage", "ponytail", "pantyhose", "purple_eyes", "cat_ears", "socks", "jewelry", "ahoge", "silver_hair", "animal_ears", "pink_hair", "braid", "red_hair", "purple_hair", "earrings", "tail", "outfit", "hairband", "detached_sleeves", "3girls", "weapon", "navel", "upper_body", "parted_lips", "panty", "medium_hair", "standing", "cowboy_shot", "sitting", "yellow_eyes", "glasses", "food", "holding", "ass", "choker", "frills", "grey_hair", "blue_hair", "simple_background", "white_background", "black_legwear", "stockings", "sidelocks", "weapon", "boots", "jacket", "barefoot", "short_sleeper", "one_eye_closed", "sidelocks", "hair_between_eyes", "full_body_shot", "shoes", "hair_flower", "black_gloves", "large_breasts", "medium_breasts", "small_breasts", "flat_chest", "bare_legs", "speech_bubble", "text", "signature", "artist_name", "watermark", "censored", "bar_censor", "comic", "4k", "8k", "absurdres", "highres", "monochrome", "greyscale", "sketch", "lineart", "photo-realistic", "masterpiece", "best_quality", "good_quality", "normal_quality", "bad_quality", "worst_quality", "blurry", "jpeg_artifacts", "lowres"];
    const SUGGESTION_MAP = {
        'default': ['masterpiece', 'highres', '1girl', 'solo'],
        '1girl': ['smile', 'blush', 'long_hair', 'looking_at_viewer'],
        'school_uniform': ['pleated_skirt', 'sailor_collar', 'serafuku', 'thighhighs'],
        'dress': ['frills', 'ribbon', 'sleeveless_dress'],
        'outdoors': ['sky', 'day', 'clouds', 'tree'],
        'night': ['moon', 'stars', 'night_sky'],
        'simple_background': ['white_background', 'grey_background', 'gradient_background'],
    };
    
    // Most of the JS logic from the previous step is identical and is omitted here for readability.
    // The following includes the NEW and MODIFIED sections.

    // --- DOM Elements ---
    const body = document.body;
    const allInputs = document.querySelectorAll('input, textarea, select');
    const tagInput = document.getElementById('tagInput');
    const swapsInput = document.getElementById('swapsInput');
    const implicationsInput = document.getElementById('implicationsInput');
    const blacklistInput = document.getElementById('blacklistInput');
    const triggerInput = document.getElementById('triggerInput');
    const appendInput = document.getElementById('appendInput');
    const deduplicateToggle = document.getElementById('deduplicateToggle');
    const underscoreToggle = document.getElementById('underscoreToggle');
    const sortSelect = document.getElementById('sortSelect');
    const maxTagsInput = document.getElementById('maxTagsInput');
    const tagOutput = document.getElementById('tagOutput');
    const processedTagsLabel = document.getElementById('processedTagsLabel');
    const copyButton = document.getElementById('copyButton');
    const copyMessage = document.getElementById('copyMessage');
    const historyContainer = document.getElementById('history-container');
    const autocompleteBox = document.getElementById('autocomplete-box');
    const suggestBtn = document.getElementById('suggest-btn');
    const themeButtons = document.querySelectorAll('.theme-button');

    // --- State --- (largely unchanged)
    let baseTags = [], copyHistory = [], autocomplete = { active: false, index: -1, suggestions: [] }, sortable;

    // --- Core Logic (processAll, displayTags, createTagElement, etc.) ---
    // This block is functionally identical to the previous version and is omitted for brevity.
    // ... (All the functions for processing, displaying, sorting, weighting tags)

    // --- NEW: Theme Switcher ---
    function applyTheme(theme) {
        body.className = theme;
        themeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === theme);
        });
        localStorage.setItem('danbooru-tag-helper-theme', theme);
    }

    // --- NEW: Suggest Tags ---
    function suggestCoherentTags() {
        const currentTags = new Set(tagInput.value.replace(/[\n\s]+/g, ',').split(',').map(t => t.trim().toLowerCase()).filter(Boolean));
        let potentialSuggestions = new Set();
        
        currentTags.forEach(tag => {
            if (SUGGESTION_MAP[tag]) {
                SUGGESTION_MAP[tag].forEach(s => potentialSuggestions.add(s));
            }
        });

        if (potentialSuggestions.size === 0) {
            SUGGESTION_MAP['default'].forEach(s => potentialSuggestions.add(s));
        }
        
        // Filter out tags already present
        let newSuggestions = [...potentialSuggestions].filter(s => !currentTags.has(s));
        
        // Shuffle and pick 2-3
        newSuggestions.sort(() => 0.5 - Math.random());
        const suggestionsToAdd = newSuggestions.slice(0, Math.min(newSuggestions.length, 3));

        if (suggestionsToAdd.length > 0) {
            const separator = tagInput.value.trim().length > 0 && !tagInput.value.trim().endsWith(',') ? ', ' : '';
            tagInput.value += separator + suggestionsToAdd.join(', ');
            processAll();
        }
    }
    
    // --- Event Listeners ---
    allInputs.forEach(input => {
        input.addEventListener('input', processAll);
        if (input.tagName === 'SELECT') input.addEventListener('change', displayTags);
    });
    
    tagInput.addEventListener('keyup', handleAutocomplete);
    tagInput.addEventListener('keydown', handleAutocomplete);
    tagInput.addEventListener('blur', () => setTimeout(hideAutocomplete, 100));
    copyButton.addEventListener('click', copyTagsToClipboard);
    suggestBtn.addEventListener('click', suggestCoherentTags);
    themeButtons.forEach(btn => btn.addEventListener('click', () => applyTheme(btn.dataset.theme)));

    // --- Initial Load ---
    const savedTheme = localStorage.getItem('danbooru-tag-helper-theme') || 'theme-indigo';
    applyTheme(savedTheme);
    processAll();
    updateCopyHistory();


    // --- PASTE THE FULL JS FROM THE PREVIOUS STEP HERE ---
    // To make this fully runnable, copy all the JavaScript functions from the
    // "Danbooru Tag Helper Ultimate" code block and paste them here, then add
    // the new theme and suggest functions as shown above.
    
    // --- Placeholder for the rest of the JS ---
    const SMART_SORT_CATEGORIES = [ { name: 'Subject Count', keywords: ['solo', 'duo', 'trio', 'group'], regex: /^\d+(boy|girl)s?$/ }, { name: 'Character/Series', keywords: ['hatsune_miku', 'gawr_gura', 'genshin_impact', 'hololive', 'touhou'] }, { name: 'Subject Focus', keywords: ['portrait', 'full_body', 'upper_body', 'cowboy_shot', 'face', 'close-up'] }, { name: 'Pose/Action', keywords: ['looking_at_viewer', 'sitting', 'standing', 'lying', 'pout', 'spread_legs', 'on_back'] }, { name: 'Facial Expression', keywords: ['smile', 'open_mouth', 'blush', 'sad', 'angry', 'crying', 'tongue_out', 'ahegao'] }, { name: 'Body', keywords: ['breasts', 'ass', 'thighs', 'pussy', 'penis', 'navel', 'feet', 'hands', 'small_breasts', 'large_breasts'] }, { name: 'Hair', regex: /.+_hair$/, keywords: ['ahoge'] }, { name: 'Eyes', regex: /.+_eyes$/ }, { name: 'Clothing', keywords: ['school_uniform', 'dress', 'shirt', 'skirt', 'pants', 'bra', 'panties', 'bikini', 'swimsuit', 'naked', 'nude'] }, { name: 'Accessories', keywords: ['hat', 'glasses', 'ribbon', 'jewelry', 'hairband', 'choker', 'cat_ears', 'tail'] }, { name: 'Setting', keywords: ['simple_background', 'white_background', 'transparent_background', 'outdoors', 'indoors', 'night', 'day', 'cityscape', 'sky', 'room'] }, { name: 'Art Style/Meta', keywords: ['monochrome', 'sketch', 'lineart', 'greyscale', 'comic', 'photo-realistic', 'masterpiece', 'best_quality', 'highres'] } ];
    function processAll() { const blacklist = new Set(blacklistInput.value.split(',').map(w => w.trim().toLowerCase()).filter(Boolean)); const swaps = new Map(swapsInput.value.split(',').map(s => s.split('->').map(p => p.trim())).filter(p => p.length === 2 && p[0])); const implications = new Map(implicationsInput.value.split(',').map(s => s.split('=>').map(p => p.trim())).filter(p => p.length === 2 && p[0])); let tags = new Set(tagInput.value.replace(/[\n\s]+/g, ',').split(',').map(t => t.trim().toLowerCase()).filter(Boolean)); tags = new Set(Array.from(tags).map(tag => swaps.get(tag) || tag)); const tagsToAdd = new Set(); tags.forEach(tag => { if (implications.has(tag)) { tagsToAdd.add(implications.get(tag)); } }); tagsToAdd.forEach(tag => tags.add(tag)); let filteredTags = Array.from(tags).filter(tag => ![...blacklist].some(b => tag.includes(b))); const maxTags = parseInt(maxTagsInput.value, 10) || 75; const newBaseTags = []; const existingTagsMap = new Map(baseTags.map(t => [t.original, t])); filteredTags.slice(0, maxTags).forEach(tag => { if (existingTagsMap.has(tag)) { newBaseTags.push(existingTagsMap.get(tag)); } else { newBaseTags.push({ original: tag, weighted: tag, id: `tag-${Math.random()}` }); } }); baseTags = newBaseTags; displayTags(); }
    function displayTags() { const maxTags = parseInt(maxTagsInput.value, 10) || 75; processedTagsLabel.querySelector('#tagCount').textContent = baseTags.length; processedTagsLabel.querySelector('#maxTagCount').textContent = maxTags; tagOutput.innerHTML = ''; if (baseTags.length === 0) { tagOutput.innerHTML = '<span class="text-gray-500 italic">Start typing...</span>'; copyButton.disabled = true; return; } const sortOrder = sortSelect.value; let tagsToDisplay = [...baseTags]; if (sortOrder === 'smart') { tagsToDisplay.sort((a, b) => { const pA = SMART_SORT_CATEGORIES.findIndex(c => getTagCategoryName(a) === c.name); const pB = SMART_SORT_CATEGORIES.findIndex(c => getTagCategoryName(b) === c.name); if (pA !== pB) return pA - pB; return a.original.localeCompare(b.original); }); } else if (sortOrder === 'az') tagsToDisplay.sort((a, b) => a.original.localeCompare(b.original)); else if (sortOrder === 'za') tagsToDisplay.sort((a, b) => b.original.localeCompare(a.original)); if (sortOrder === 'smart') { const groups = tagsToDisplay.reduce((acc, tag) => { const categoryName = getTagCategoryName(tag); if (!acc[categoryName]) acc[categoryName] = []; acc[categoryName].push(tag); return acc; }, {}); const sortedCategoryNames = [...SMART_SORT_CATEGORIES.map(c => c.name), 'Other']; sortedCategoryNames.forEach(categoryName => { if (groups[categoryName]) { const groupDiv = document.createElement('div'); groupDiv.className = 'tag-group'; groupDiv.innerHTML = `<h3 class="tag-group-title">${categoryName}</h3>`; const container = document.createElement('div'); container.className = 'tag-group-container'; container.dataset.groupName = categoryName; groups[categoryName].forEach(tag => container.appendChild(createTagElement(tag))); groupDiv.appendChild(container); tagOutput.appendChild(groupDiv); } }); } else { const container = document.createElement('div'); container.className = 'tag-group-container'; container.dataset.groupName = 'all'; tagsToDisplay.forEach(tag => container.appendChild(createTagElement(tag))); tagOutput.appendChild(container); } copyButton.disabled = false; initSortable(); }
    function createTagElement(tag) { const el = document.createElement('div'); el.className = 'tag-base processed-tag'; el.dataset.id = tag.id; el.oncontextmenu = (e) => { e.preventDefault(); const weight = prompt(`Enter weight for "${tag.original}" (e.g., 1.1):`, '1.1'); if (weight && !isNaN(parseFloat(weight))) { tag.weighted = `(${tag.original}:${weight})`; displayTags(); } }; const useUnderscores = underscoreToggle.checked; const displayTag = useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' '); el.innerHTML = `<button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'decrease')" title="Decrease weight">-</button><span class="tag-text">${displayTag}</span><button class="tag-weight-btn" onclick="updateTagWeight('${tag.id}', 'increase')" title="Increase weight">+</button>`; return el; }
    window.updateTagWeight = (id, action) => { const tag = baseTags.find(t => t.id === id); if (!tag) return; let current = tag.weighted; const original = tag.original; if (action === 'increase') { if (current.startsWith('[')) current = original; else if (current.startsWith('((')) current = `(((${original})))`; else if (current.startsWith('(')) current = `((${original}))`; else current = `(${original})`; } else { if (current.startsWith('(')) current = original; else if (current.startsWith('[[')) current = `[[[${original}]]]`; else if (current.startsWith('[')) current = `[[${original}]]`; else current = `[${original}]`; } tag.weighted = current; displayTags(); };
    function getTagCategoryName(tag) { const tagLower = (tag.original || tag).toLowerCase().replace(/ /g, '_'); for (const category of SMART_SORT_CATEGORIES) { if (category.keywords?.some(k => tagLower.includes(k)) || category.regex?.test(tagLower)) return category.name; } return 'Other'; }
    function initSortable() { if (sortable) sortable.destroy(); const containers = tagOutput.querySelectorAll('.tag-group-container'); containers.forEach(container => { sortable = new Sortable(container, { group: 'shared', animation: 150, ghostClass: 'opacity-50', onStart: () => { sortSelect.value = 'manual'; }, onEnd: (evt) => { const tagId = evt.item.dataset.id; const movedTag = baseTags.find(t => t.id === tagId); const oldIndex = baseTags.indexOf(movedTag); baseTags.splice(oldIndex, 1); const newContainer = evt.to; const newIndexInDOM = Array.from(newContainer.children).indexOf(evt.item); let newGlobalIndex = 0; for (const cont of tagOutput.querySelectorAll('.tag-group-container')) { if (cont === newContainer) { newGlobalIndex += newIndexInDOM; break; } newGlobalIndex += cont.children.length; } baseTags.splice(newGlobalIndex, 0, movedTag); displayTags(); }, }); }); }
    function handleAutocomplete(e) { const text = tagInput.value; const cursorPos = tagInput.selectionStart; const lastComma = text.lastIndexOf(',', cursorPos - 1); const currentWord = text.substring(lastComma + 1, cursorPos).trim(); if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter') { if (!autocomplete.active) return; e.preventDefault(); if (e.key === 'ArrowDown') autocomplete.index = (autocomplete.index + 1) % autocomplete.suggestions.length; if (e.key === 'ArrowUp') autocomplete.index = (autocomplete.index - 1 + autocomplete.suggestions.length) % autocomplete.suggestions.length; if (e.key === 'Enter') { if(autocomplete.suggestions[autocomplete.index]) selectAutocompleteItem(autocomplete.suggestions[autocomplete.index]); return; } updateAutocompleteSelection(); return; } if (!currentWord) { hideAutocomplete(); return; } autocomplete.suggestions = TAG_DATABASE.filter(t => t.startsWith(currentWord)).slice(0, 5); if (autocomplete.suggestions.length > 0) { autocomplete.active = true; autocomplete.index = -1; renderAutocomplete(); } else { hideAutocomplete(); } }
    function renderAutocomplete() { autocompleteBox.innerHTML = autocomplete.suggestions.map((s, i) => `<div class="autocomplete-item ${i === autocomplete.index ? 'selected' : ''}" onmousedown="selectAutocompleteItem('${s}')">${s}</div>`).join(''); autocompleteBox.style.display = 'block'; }
    function updateAutocompleteSelection() { Array.from(autocompleteBox.children).forEach((child, i) => { child.classList.toggle('selected', i === autocomplete.index); }); }
    window.selectAutocompleteItem = (tag) => { const text = tagInput.value; const cursorPos = tagInput.selectionStart; const lastComma = text.lastIndexOf(',', cursorPos - 1); const before = text.substring(0, lastComma + 1); const after = text.substring(text.indexOf(' ', lastComma + currentWord.length +1)); const currentWord = text.substring(lastComma + 1, cursorPos).trim(); tagInput.value = `${before} ${tag}, ${text.substring(cursorPos)}`; hideAutocomplete(); tagInput.focus(); processAll(); };
    function hideAutocomplete() { autocomplete.active = false; autocompleteBox.style.display = 'none'; }
    function copyTagsToClipboard() { const useUnderscores = underscoreToggle.checked; const triggers = triggerInput.value.split(',').map(t => t.trim()).filter(Boolean); const appends = appendInput.value.split(',').map(t => t.trim()).filter(Boolean); const processed = baseTags.map(tag => useUnderscores ? tag.weighted.replace(/\s/g, '_') : tag.weighted.replace(/_/g, ' ')); const finalString = [...triggers, ...processed, ...appends].join(', '); navigator.clipboard.writeText(finalString).then(() => { copyMessage.textContent = 'Tags copied!'; updateCopyHistory(finalString); setTimeout(() => copyMessage.textContent = '', 2000); }).catch(err => { copyMessage.textContent = 'Copy failed!'; }); }
    function updateCopyHistory(text) { if(text){ copyHistory.unshift(text); if (copyHistory.length > 10) copyHistory.pop(); } historyContainer.innerHTML = ''; if (copyHistory.length === 0) { historyContainer.innerHTML = `<p class="text-sm text-gray-500 italic">No history yet.</p>`; return; } copyHistory.forEach(item => { const el = document.createElement('div'); el.className = 'history-item p-2 rounded-md flex items-center justify-between gap-2'; el.innerHTML = `<span class="history-item-text text-gray-400 text-xs flex-grow overflow-hidden whitespace-nowrap text-ellipsis">${item}</span><button class="copy-btn-sm p-1 rounded" onclick="navigator.clipboard.writeText(\`${item.replace(/`/g, '\\`')}\`)"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>`; historyContainer.appendChild(el); }); }
    
    </script>
</body>
</html>
